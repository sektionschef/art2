<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Art projects</title><link>https://digitalitility.com/posts/</link><description>Recent content in Posts on Art projects</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>&lt;a href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank" rel="noopener">CC BY-NC 4.0&lt;/a></copyright><lastBuildDate>Sat, 08 Jan 2022 17:01:30 +0100</lastBuildDate><atom:link href="https://digitalitility.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>CO² emissions in digital painting</title><link>https://digitalitility.com/posts/2022/01/co-emissions-in-digital-painting/</link><pubDate>Sat, 08 Jan 2022 17:01:30 +0100</pubDate><guid>https://digitalitility.com/posts/2022/01/co-emissions-in-digital-painting/</guid><description> The digital painting visualizes the increasing CO² concentration in the earth&amp;rsquo;s atmosphere between 2012 and 2021. It&amp;rsquo;s a generative piece of art which never looks the same.
The artwork itself is here: https://sektionschef.github.io/generative_co2/ More information here -&amp;gt; https://medium.com/@sektionschef/co%C2%B2-emissions-in-digital-painting-3e979c2e6a04 The code repo is here: https://github.com/sektionschef/generative_co2 the clean nft OBJKT is here: https://hicetnunc.art/objkt/624714</description><content type="html"><![CDATA[<figure><img src="thumbnail_detail.gif"
         alt="Detail view of animation"/>
</figure>

<p>The digital painting visualizes the <strong>increasing CO² concentration</strong> in the earth&rsquo;s atmosphere between 2012 and 2021. It&rsquo;s a generative piece of art which <strong>never looks the same</strong>.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/TveLm4kC7hE" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<ul>
<li>The artwork itself is here: <a href="https://sektionschef.github.io/generative_co2/">https://sektionschef.github.io/generative_co2/</a></li>
<li>More information here -&gt; <a href="https://medium.com/@sektionschef/co%C2%B2-emissions-in-digital-painting-3e979c2e6a04">https://medium.com/@sektionschef/co%C2%B2-emissions-in-digital-painting-3e979c2e6a04</a></li>
<li>The code repo is here: <a href="https://github.com/sektionschef/generative_co2">https://github.com/sektionschef/generative_co2</a></li>
<li>the clean nft OBJKT is here: <a href="https://hicetnunc.art/objkt/624714">https://hicetnunc.art/objkt/624714</a></li>
</ul>
]]></content></item><item><title>COVID-19 on abstract painting</title><link>https://digitalitility.com/posts/2020/09/covid-19-on-abstract-painting/</link><pubDate>Mon, 14 Sep 2020 12:27:30 +0100</pubDate><guid>https://digitalitility.com/posts/2020/09/covid-19-on-abstract-painting/</guid><description>Read the whole story here: https://medium.com/@sektionschef/abstract-painting-visualizes-regional-covid-19-infections-in-real-time-b43b6c2a9e70</description><content type="html"><![CDATA[
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/d66fJ7CNeHE" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>Read the whole story here:
<a href="https://medium.com/@sektionschef/abstract-painting-visualizes-regional-covid-19-infections-in-real-time-b43b6c2a9e70">https://medium.com/@sektionschef/abstract-painting-visualizes-regional-covid-19-infections-in-real-time-b43b6c2a9e70</a></p>
]]></content></item><item><title>Paintings</title><link>https://digitalitility.com/posts/2015/01/paintings/</link><pubDate>Thu, 01 Jan 2015 12:27:30 +0100</pubDate><guid>https://digitalitility.com/posts/2015/01/paintings/</guid><description> Nagano - Acrylic on canvas, 160x100cm Wühlmaus Skeleton Staro Magazino Dochboden Schuachschochtl 1 Schuachschochtl 2 Schuachschochtl 3</description><content type="html"><![CDATA[<p><figure><img src="nagano_ub.jpg"/><figcaption>
            <h4>Nagano - Acrylic on canvas, 160x100cm</h4>
        </figcaption>
</figure>

<figure><img src="P1020296.jpg"/><figcaption>
            <h4>Wühlmaus</h4>
        </figcaption>
</figure>

<figure><img src="P1020294.jpg"/><figcaption>
            <h4>Skeleton</h4>
        </figcaption>
</figure>

<figure><img src="P1020293.jpg"/><figcaption>
            <h4>Staro</h4>
        </figcaption>
</figure>

<figure><img src="P1020291.jpg"/><figcaption>
            <h4>Magazino</h4>
        </figcaption>
</figure>

<figure><img src="P1020289.jpg"/><figcaption>
            <h4>Dochboden</h4>
        </figcaption>
</figure>

<figure><img src="P1020285.jpg"/><figcaption>
            <h4>Schuachschochtl 1</h4>
        </figcaption>
</figure>

<figure><img src="P1020282.jpg"/><figcaption>
            <h4>Schuachschochtl 2</h4>
        </figcaption>
</figure>

<figure><img src="P1020287.jpg"/><figcaption>
            <h4>Schuachschochtl 3</h4>
        </figcaption>
</figure>
</p>
]]></content></item><item><title>Hello world, hello futuregarden</title><link>https://digitalitility.com/posts/2014/11/hello-world-hello-futuregarden/</link><pubDate>Tue, 25 Nov 2014 12:27:30 +0100</pubDate><guid>https://digitalitility.com/posts/2014/11/hello-world-hello-futuregarden/</guid><description>What an honor: my projection painting prototype was publicly featured in futuregarden for 2 weeks. The original canvas was repainted with 5 different colors.
At the entrance of the futuregarden a beamer, a laptop running my processing script (here at github), an arduino uno and a hall sensor were hooked up. The beamer pointing at the canvas projected five additional colors to create five new colors.
Each time the door of the futuregarden was opened and somebody entered or left.</description><content type="html"><![CDATA[<p>What an honor: my <a href="http://digit.alitility.com/visualitility/projection-painting-prototype/" title="Projection Painting Prototype">projection painting prototype</a> was publicly featured in <a href="https://www.facebook.com/futuregarden">futuregarden</a> for 2 weeks. The original canvas was repainted with 5 different colors.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/6cnZBFc5yuE" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>At the entrance of the futuregarden a beamer, a laptop running my <a href="https://processing.org/">processing</a> script (<a href="https://github.com/sektionschef/proiezione">here at github</a>), an <a href="http://www.arduino.cc/">arduino</a> uno and a hall sensor were hooked up. The beamer pointing at the canvas projected five additional colors to create five new colors.</p>
<p><figure><img src="futuregarden_beamer.jpg"
         alt="Futuregarden Beamer"/>
</figure>

<figure><img src="futuregarden_hallsensor.jpg"
         alt="Futuregarden Beamer"/>
</figure>

<figure><img src="futuregarden_inaction01.jpg"
         alt="Futuregarden in Action 01"/>
</figure>

<figure><img src="futuregarden_inaction03.jpg"
         alt="Futuregarden in Action 03"/>
</figure>

<figure><img src="futuregarden_lightson.jpg"
         alt="Futuregarden Lights on"/>
</figure>

<figure><img src="futuregarden_nobeamer.jpg"
         alt="Futuregarden no Beamer"/>
</figure>

<figure><img src="futuregarden_inaction02.jpg"
         alt="Futuregarden in Action 02"/>
</figure>
</p>
<p>Each time the door of the futuregarden was opened and somebody entered or left., five new colors were thrown on the canvas. These five-color palettes were created using the &ldquo;crowd-color&rdquo; platform <a href="http://www.colourlovers.com/">colorlovers</a>. In addtion, to my own color palettes, I featured some others I liked:</p>
<ul>
<li><a href="http://www.colourlovers.com/palette/3388285/juno?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3388/3388285_juno.png" alt="juno"></a></li>
<li><a href="http://www.colourlovers.com/palette/3393359/roger_miller?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3393/3393359_roger_miller.png" alt="roger_miller"></a></li>
<li><a href="http://www.colourlovers.com/palette/3399500/who_rang?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3399/3399500_who_rang.png" alt="who_rang"></a></li>
<li><a href="http://www.colourlovers.com/palette/3367669/She_Tells_Herself?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3367/3367669_She_Tells_Herself.png" alt="She_Tells_Herself"></a></li>
<li><a href="http://www.colourlovers.com/palette/3399454/barbie_soldier"><img src="http://www.colourlovers.com/images/badges/p/3399/3399454_barbie_soldier.png" alt="barbie_soldier"></a></li>
<li><a href="http://www.colourlovers.com/palette/3399464/im_a_rocket"><img src="http://www.colourlovers.com/images/badges/p/3399/3399464_im_a_rocket.png" alt="im_a_rocket"></a></li>
<li><a href="http://www.colourlovers.com/palette/3399484/verrazano"><img src="http://www.colourlovers.com/images/badges/p/3399/3399484_verrazano.png" alt="verrazano"></a></li>
<li><a href="http://www.colourlovers.com/palette/3419291/may?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3419/3419291_may.png" alt="may"></a></li>
<li><a href="http://www.colourlovers.com/palette/3419301/brunnen?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3419/3419301_brunnen.png" alt="brunnen"></a></li>
<li><a href="http://www.colourlovers.com/palette/3419311/old_profs_beard?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3419/3419311_old_profs_beard.png" alt="old_profs_beard"></a></li>
<li><a href="http://www.colourlovers.com/palette/3419289/Summer_Thoughts?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3419/3419289_Summer_Thoughts.png" alt="Summer_Thoughts"></a></li>
<li><a href="http://www.colourlovers.com/palette/3531033/random_192?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3531/3531033_random_192.png" alt="random_192"></a></li>
<li><a href="http://www.colourlovers.com/palette/3531024/EstanteDaImagina%C3%A7%C3%A3o"><img src="http://www.colourlovers.com/images/badges/p/3531/3531024_EstanteDaImaginao.png" alt="EstanteDaImaginação"></a></li>
<li><a href="http://www.colourlovers.com/palette/3531020/Mauve"><img src="http://www.colourlovers.com/images/badges/p/3531/3531020_Mauve.png" alt="Mauve"></a></li>
<li><a href="http://www.colourlovers.com/palette/3531018/No_Clever_Title"><img src="http://www.colourlovers.com/images/badges/p/3531/3531018_No_Clever_Title.png" alt="No_Clever_Title"></a></li>
<li><a href="http://www.colourlovers.com/palette/3531016/cloth"><img src="http://www.colourlovers.com/images/badges/p/3531/3531016_cloth.png" alt="cloth"></a></li>
<li><a href="http://www.colourlovers.com/palette/3531012/Snacks_On_Sunday?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3531/3531012_Snacks_On_Sunday.png" alt="Snacks_On_Sunday"></a></li>
<li><a href="http://www.colourlovers.com/palette/3531008/Rewind_Start_Over?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3531/3531008_Rewind_Start_Over.png" alt="Rewind_Start_Over"></a></li>
<li><a href="http://www.colourlovers.com/palette/3530997/Black_Gold?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3530/3530997_Black_Gold.png" alt="Black_Gold"></a></li>
<li><a href="http://www.colourlovers.com/palette/3530990/I_Go_In_And_Out?widths=1"><img src="http://www.colourlovers.com/images/badges/pw/3530/3530990_I_Go_In_And_Out.png" alt="I_Go_In_And_Out"></a></li>
</ul>
<p>The result was the perfect atmosphere to enjoy a beer.</p>
]]></content></item><item><title>Data Painting - The Past in Realtime</title><link>https://digitalitility.com/posts/2014/09/data-painting-the-past-in-realtime/</link><pubDate>Sun, 28 Sep 2014 12:27:30 +0100</pubDate><guid>https://digitalitility.com/posts/2014/09/data-painting-the-past-in-realtime/</guid><description>After the infamous projection prototype, my first work is finished: the past in realtime. It displays our team&amp;rsquo;s diverging efforts for each minute of the day on a painted canvas. Based on the data of 51.000 time entries of ambuzzador&amp;rsquo;s past, the painting explains the distribution of our working time for six categories: project management, meetings, conceptual design, consulting, editorial services and content creation. For each minute, six color tones are projected on variably sized, painted areas.</description><content type="html"><![CDATA[<figure><img src="Untitled_kl1.gif"
         alt="past in realtime gif"/>
</figure>

<p>After the infamous <a href="http://digit.alitility.com/visualitility/projection-painting-prototype/" title="Projection Painting Prototype">projection prototype</a>, my first work is finished: the past in realtime. It displays our team&rsquo;s diverging efforts for each minute of the day on a painted canvas. Based on the data of 51.000 time entries of <a href="http://ambuzzador.com/">ambuzzador</a>&rsquo;s past, the painting explains the distribution of our working time for six categories: project management, meetings, conceptual design, consulting, editorial services and content creation. For each minute, six color tones are projected on variably sized, painted areas. For instance, the amount of the screen the blue color fills is the proportion of the work spent on meetings at that time. In short: A pie chart without a pie.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/CLqPOSmoUIo" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<h2 id="how-it-was-done">How it was done</h2>
<p>I took the timesheets, which hold the exact date and time when a particular task was started and ended - about 51.000 eintries since 2011. When expanding the time entries for every minute ranging from the minute started and the minute ended the data grew to about 21 billion entries.</p>
<p>For the real-world part of this project, I painted a canvas with 133 abstract polygons with some inspiration of good old <a href="http://en.wikipedia.org/wiki/Kazimir_Malevich">Kazimir Malevich</a>. The areas' outlines were transformed to a virtual clone in svg format. And then wrote an <a href="http://www.r-project.org/">R</a> script to calculate the area of each polygon and to normalize them.</p>
<p>Finally, the areas of the canvas had to be chosen so that the sum of their areas best matches the proportion for each task category in each minute. This combinatorial optimization riddle is known as the <a href="http://en.wikipedia.org/wiki/Knapsack_problem">Knapsack problem</a> in literature and obviously there is no other solution than to test every single combination, brute force. In order to compensate the lack of supercomputers at home, I randomly created seven groups from all the polygons. This way the combinations were reduced to 2 million per minute and per category. It took 32 hours for my computer to come up with the optimal solution for presenting the ambuzzador&rsquo;s past in realtime. The maximal deviance between data and canvas is about 2% with a standard error of 0.087%.</p>
<p>The projection painting was done <a href="http://digit.alitility.com/visualitility/projection-painting-prototype/" title="Projection Painting Prototype">again</a> in <a href="http://processing.org/">Processing</a> using keystone library. The whole project took about 3 months. The source code is publicly available on github: <a href="https://github.com/sektionschef/10yearsbuzz">https://github.com/sektionschef/10yearsbuzz</a></p>
<figure><img src="P1070764.jpg"
         alt="past in realtime start"/>
</figure>

<figure><img src="P1070776.jpg"
         alt="past in realtime transform to svg"/>
</figure>

<figure><img src="P1070792_ub.jpg"
         alt="past in realtime finished"/>
</figure>

<figure><img src="Untitled_kl1.gif"
         alt="Untitled_kl"/>
</figure>

<h2 id="with-special-thanks-to">with special thanks to</h2>
<ul>
<li><a href="https://gist.github.com/ivanpike/5236688">https://gist.github.com/ivanpike/5236688</a> - multiple surfaces for keystone library in processing</li>
<li><a href="http://de.wikihow.com/Die-Fl%C3%A4che-eines-Vielecks-berechnen">http://de.wikihow.com/Die-Fl%C3%A4che-eines-Vielecks-berechnen</a> - calculating areas of polygons</li>
<li><a href="http://stackoverflow.com/questions/21868326/r-scraping-web-with-xpathsapply">http://stackoverflow.com/questions/21868326/r-scraping-web-with-xpathsapply</a> - getting xml/svg in R</li>
<li><a href="http://forum.processing.org/two/">http://forum.processing.org/two/</a> - all the open source communities</li>
</ul>
]]></content></item><item><title>Projection Painting Prototype</title><link>https://digitalitility.com/posts/2014/07/projection-painting-prototype/</link><pubDate>Thu, 17 Jul 2014 12:27:30 +0100</pubDate><guid>https://digitalitility.com/posts/2014/07/projection-painting-prototype/</guid><description>Executive Summary The structure of the canvas, mixing colors right on the canvas, layer after layer and letting the coincidence help is what makes traditional painting so powerful. However, as a nerdophile person I often miss the undo button and the color wheel of the digital world.
Luckily, I came across the processing movement turning code into art and vice versa. The perfect base to combine vivid richness of painted structure with the interactive and dynamic power of code.</description><content type="html"><![CDATA[<h1 id="executive-summary">Executive Summary</h1>
<p>The structure of the canvas, mixing colors right on the canvas, layer after layer and letting the coincidence help is what makes traditional painting so powerful. However, as a nerdophile person I often miss the <em>undo</em> button and the color wheel of the digital world.</p>
<figure><img src="P1070736.jpg"
         alt="Projection_Painting_Prototype_01"/>
</figure>

<p>Luckily, I came across the <a href="http://processing.org/">processing</a> movement turning code into art and vice versa. The perfect base to combine vivid richness of painted structure with the interactive and dynamic power of code. In fact, I had the idea of creating a painting hanging in a local club and each time someone enters or leaves the room the color palette of the painting changes.</p>
<figure><img src="scribble.jpg"
         alt="scribble_projection_painting"/>
</figure>

<p>So I bought a <a href="http://www.amazon.de/Philips-PPX2450-Taschenprojektor-Notebooks-Kontrast/dp/B006U1FAFI">Philips PPX2450 PicoPix</a> beamer, grabbed my <a href="http://arduino.cc/de/Main/ArduinoBoardUno">Arduino uno</a>, a <a href="http://www.hobbytronics.co.uk/arduino-tutorial11-hall-effect">hall effect sensor</a>, some acrylic colors and a 120x80cm canvas. Two months later I am looking at a fully functional prototype with both worlds combined. I&rsquo;ve built my first processing application, overcome <a href="http://en.wikipedia.org/wiki/Keystone_effect">keystoning</a> and mapped my virtual picture to my real one.</p>
<p>The teamplay of code and canvas enables me to visualize data or interactions in physical space.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/D3uiVWXU7KE" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>The following chapters descirbe how I did it in detail and therefore are pretty boring. Anyway, I found so much help in the online communities that this is the least I can do to help others out. The script itself is available at github: <a href="https://github.com/sektionschef/proiezione">https://github.com/sektionschef/proiezione</a></p>
<h2 id="realisation">Realisation</h2>
<h3 id="sketches-and-painting">Sketches and Painting</h3>
<p>First of all I made a paper pencil sketch for the image. Then, I transfered the real sketch to a virtual svg using inkscape (keeping the same aspect ratio, 120:80). I drew the grid and then filled it up with rectangles in five different colors. The svg helped me to decide the relative color differences. For this purpose (and also later on in processing) I switched to the <a href="http://en.wikipedia.org/wiki/HSL_and_HSV">HSV</a> color model.</p>
<p>I&rsquo;ve seen in a first attempt that exotic color combinations (beamer colors and acrylic colors) are not working that great. Due to the limited power of the Pico beamer I wasn&rsquo;t able to turn a bright yellow into a green nor a red into violet. Most imporantly, the lightness of the surface of the projection is essential: the projection can&rsquo;t overcome darker tones. For the image itself I painted <a href="http://de.wikipedia.org/wiki/Sean_Scully">Sean Scully</a>-like color fields on a 120x80cm canvas. I mapped the exact proportions of the .svg sketch as coordinates to the canvas.</p>
<p><figure><img src="first_sketch.jpg"
         alt="first_sketch"/>
</figure>

<figure><img src="Screenshot-from-2014-06-19-125012.png"
         alt="Screenshot-from-2014-06-19-125012"/>
</figure>

<figure><img src="P1070674.jpg"
         alt="d"/>
</figure>

<figure><img src="P10706791.jpg"
         alt="d"/>
</figure>

<figure><img src="P1070684.jpg"
         alt="d"/>
</figure>

<figure><img src="P1070688.jpg"
         alt="d"/>
</figure>
</p>
<h2 id="processing">Processing</h2>
<p><a href="https://www.processing.org/download/">Processing</a> is open source and the community created lots of tutorials and howtos. I use processing in <a href="http://www.vim.org/download.php">gvim</a> with the <a href="https://github.com/sophacles/vim-processing">gvim-processing plugin</a>. That&rsquo;s when I found out about the elegance of <a href="http://www.vim.org/scripts/script.php?script_id=2332">pathogen</a> by the way, highly recommend it. One should not forget to make the symbolic link in <em>/usr/bin</em> to the processing-java file in the downloaded processing directory. That took me quite some time to figure out.</p>
<p><code>sudo ln -s ~/processing-2.2.1/processing-java /usr/bin/processing-java</code></p>
<h3 id="arduino-with-hall-sensor">Arduino with Hall Sensor</h3>
<p>Like in the <a href="http://digit.alitility.com/tutori-alitility/twetterhauschen/" title="Twetterhäuschen">Twetterhaeuschen</a> and the <a href="http://digit.alitility.com/multidimensionalitility/like-converter/" title="Like Converter">Like Converter</a> firmata comes to the rescue and deals with all the complicated stuff when dealing with arduino. You can download the <em>arduino</em> library in the GUI of the IDE. In Ubuntu or Linux in general the arduino library needs to be renamed from &ldquo;Arduino.jar&rdquo; to &ldquo;arduino.jar&rdquo; - some case sensitive problem. You find it in the sketchbook folder libraries/arduino/library. Then the arduino board can be controlled directly in processing - here is all the info: <a href="http://playground.arduino.cc/Interfacing/processing">http://playground.arduino.cc/Interfacing/processing</a></p>
<h3 id="keystoning">Keystoning</h3>
<p>A really tricky part in the whole story is perspective. The coordinates of the color fields of svg and canvas are the same but since the beamer is not located right in front of the canvas the distortion of perspective needs to be corrected. That&rsquo;s mainly what projection mapping is all about, creating visual effects by light and perspective. I tried several solutions, <a href="http://hv-a.com/lpmt/">lpmt</a> and a handy <a href="http://forum.processing.org/one/topic/announcing-surfacemapper-a-projection-mapping-library.html">proejction mapping tool</a> for processing which was not supported by processing 2.0. Luckily, there was another thing which is in fact quite simple and stable. It gives you the possibility to manipulate the canvas in a three dimensional space - called <a href="http://keystonep5.sourceforge.net/">keystoning</a>. It is readily available in the plugin repository of the processing IDE.</p>
<h3 id="the-script">The script</h3>
<p>I decided to keep the color palettes in a separate csv file. I had the feeling that I will soon be doing something more extravagant with the color change. With an old-fashioned formula I linked the five colors to all the 22 fields of the painting.</p>
<p>In processing the individual elements of the svg can be loaded as <a href="http://processing.org/reference/PShape.html">PShape object</a>. They can be addressed with their ID in order to change their appearance. For instance, I needed to scale down the svg. The actual image is drawn on an offscreen surface which can be altered by the mouse after pressing C, thanks to the <a href="http://keystonep5.sourceforge.net/">keystoning library</a>.</p>
<p>The Hall sensor does its job as the <a href="http://arduino.cc/en/Tutorial/ButtonStateChange">edge detection</a>. The circuit is quite easy to accomplish, that one helps: <a href="http://www.hobbytronics.co.uk/arduino-tutorial11-hall-effect">http://www.hobbytronics.co.uk/arduino-tutorial11-hall-effect</a> .</p>
<h3 id="the-projection-setup-with-raspberry-pi-under-construction">The Projection Setup with Raspberry Pi (under construction)</h3>
<p>I was not able to implement the projection using the Raspberry Pi. Obviously, the Raspberry Pi has a problem with P3D as used in keystoning library. First, it complains it can&rsquo;t load:</p>
<p><code>failed to open vchiq</code></p>
<p>Remedy against this:</p>
<p><code>sudo chmod 777 /dev/vchiq</code></p>
<p>but then the window is not able to load, here are some references:</p>
<ul>
<li><a href="https://www.google.at/search?q=ion+cannot+be+cast+to+com.jogamp.nativewindow.awt&amp;oq=ion+cannot+be+cast+to+com.jogamp.nativewindow.awt&amp;aqs=chrome..69i64.19387j0j9&amp;client=ubuntu-browser&amp;sourceid=chrome&amp;es_sm=94&amp;ie=UTF-8">source 1</a></li>
<li><a href="http://forum.processing.org/two/discussion/4329/problem-building-processing-from-source-for-raspberry-pi-newt-p3dopengl#Item_2">source 2</a></li>
</ul>
<p>Anyway, here is what I tried until I got the error:</p>
<ol>
<li>Connect via ssh</li>
<li>start the Xserver with</li>
</ol>
<p><code>startx &amp;</code></p>
<ol>
<li>select where the graphical output should go</li>
</ol>
<p><code>export DISPLAY=&quot;:0.0&quot;</code></p>
<ol>
<li>launch the sketch via command line (<a href="http://stackoverflow.com/questions/14787093/how-to-run-processing-applications-from-the-terminal">source</a>):</li>
</ol>
<p><code>./processing-java --sketch=/home/stefan/sketchbook/proiezione --output=/tmp/processing/test --force --present</code></p>
<p>Create a VNC server for the existing Xserver (instead of tightvnc who creates a new one)</p>
<p><code>x11vnc -forever -display :0 -ultrafilexfer</code></p>
<p>Connect with xtightvncviewer (since vinagre is not working - without any reason). You should be ablet put this all in one command via ssh, if everything works:</p>
<p><code>ssh tim &quot;DISPLAY=:0 nohup firefox&quot;</code></p>
<p>(source: <a href="http://askubuntu.com/questions/47642/how-to-start-a-gui-software-on-a-remote-linux-pc-via-ssh">http://askubuntu.com/questions/47642/how-to-start-a-gui-software-on-a-remote-linux-pc-via-ssh</a>)</p>
<h2 id="plan-b-lubuntu-instead-of-raspberry-pi">Plan B Lubuntu instead of Raspberry Pi</h2>
<p>In <a href="http://lubuntu.net/">Lubuntu</a> fullscreen works, in contrast to Ubuntu&rsquo;s Unity. I installed Lubuntu on an SD card. This way I can boot to Lubuntu once the SD card is inserted.</p>
<p>Don&rsquo;t forget to add yourself to the dialout group:</p>
<p><code>sudo adduser stefan /dev/ttyACM0</code></p>
<p>Finally, the presentation mode of processing needs some tuning in the form of:</p>
<ol>
<li>by closing processing! (important)</li>
<li>opening .processing/preferences</li>
<li>edit run.present.bgcolor=#000000 and</li>
<li>edit run.present.stop.color=#000000</li>
</ol>
<p>That&rsquo;s basically it.</p>
<h2 id="additional-literature">Additional literature</h2>
<ul>
<li><a href="http://www.amazon.de/Aesthetics-Interaction-Digital-Art-English-ebook/dp/B00FGIFN80/">Aesthetics of Interaction in Digital Art by Katja Kwastek</a></li>
<li><a href="http://www.amazon.de/Interaction-Color-Josef-Albers/dp/0300179359/">Interaction Of Color by Josef Albers</a></li>
<li><a href="http://mitpress.mit.edu/books/processing%20">Ben Fry and Casey Reas on Processing</a></li>
</ul>
]]></content></item><item><title>Like Converter</title><link>https://digitalitility.com/posts/2014/04/like-converter/</link><pubDate>Tue, 29 Apr 2014 12:27:30 +0100</pubDate><guid>https://digitalitility.com/posts/2014/04/like-converter/</guid><description>The Like Converter transforms likes earned for a Facebook posting into delicious candy. It is a reward system for social media managers and a source of motivation for your desk.
The thing itself is built (like the [Twetterhaeuschen] (https://digitalitility.com/posts/2013/11/twetterh%C3%A4uschen/ )) on a raspberry pi, an arduino uno using node.js and firmata. The source code is on github: https://github.com/sektionschef/like_converter</description><content type="html"><![CDATA[<p>The Like Converter transforms likes earned for a Facebook posting into delicious candy. It is a reward system for social media managers and a source of motivation for your desk.</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/qcssBxjWfE8" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<p>The thing itself is built (like the [Twetterhaeuschen] (https://digitalitility.com/posts/2013/11/twetterh%C3%A4uschen/ )) on a <a href="http://www.raspberrypi.org/" title="raspberry pi">raspberry pi</a>, an <a href="http://www.arduino.cc/">arduino</a> uno using <a href="http://nodejs.org/">node.js</a> and <a href="http://arduino.cc/en/reference/firmata">firmata</a>. The source code is on github: <a href="https://github.com/sektionschef/like_converter">https://github.com/sektionschef/like_converter</a></p>
<p><figure><img src="P1060877.jpg"
         alt="Like converter"/>
</figure>

<figure><img src="P1060880.jpg"
         alt="The Like Converter sign"/>
</figure>

<figure><img src="P1060883.jpg"
         alt="Like converter 2"/>
</figure>

<figure><img src="P1060893.jpg"
         alt="Like converter 3"/>
</figure>
</p>
]]></content></item><item><title>Die Dübitale Revolution</title><link>https://digitalitility.com/posts/2014/03/die-d%C3%BCbitale-revolution/</link><pubDate>Sun, 30 Mar 2014 12:27:30 +0100</pubDate><guid>https://digitalitility.com/posts/2014/03/die-d%C3%BCbitale-revolution/</guid><description>Bayrische Großvisionäre haben das Tor zu einer neuen Dimension aufgestoßen. Die &amp;ldquo;Dübitalanzeige&amp;rdquo; besteht aus einem Holzbrett, in das durch präzise Bohrungen einzelne Dübel von Hand variabel angeordnet werden können. Je nach Dübelsetzung kann so, eine gewisse geistige Flexibilität vorausgesetzt, eine kurze Botschaft encodiert werden, ohne ein einziges Watt zu verbrauchen.
Die &amp;ldquo;Dübitalanzeige&amp;rdquo; ist der erste große Schritt Richtung dübitaler Ära. Ob das Pixel tatsächlich dem Düxel Platz machen werden muss, wird sich erst in den nächsten Jahren herauskristallisieren.</description><content type="html"><![CDATA[<figure><img src="P1060868.jpg"
         alt="duebitalanzeige"/>
</figure>

<p>Bayrische Großvisionäre haben das Tor zu einer neuen Dimension aufgestoßen. Die &ldquo;Dübitalanzeige&rdquo; besteht aus einem Holzbrett, in das durch präzise Bohrungen einzelne Dübel von Hand variabel angeordnet werden können. Je nach Dübelsetzung kann so, eine gewisse geistige Flexibilität vorausgesetzt, eine kurze Botschaft encodiert werden, ohne ein einziges Watt zu verbrauchen.</p>
<p><figure><img src="P1060863.jpg"
         alt="Rückseite der Dübitalanzeige"/>
</figure>

<figure><img src="P1060871.jpg"
         alt="das Düxel"/>
</figure>

<figure><img src="P1060868.jpg"
         alt="Close Up"/>
</figure>

<figure><img src="P1060866.jpg"
         alt="Donkschen geschrieben auf der Dübitalanzeige"/>
</figure>
</p>
<p>Die &ldquo;Dübitalanzeige&rdquo; ist der erste große Schritt Richtung dübitaler Ära. Ob das Pixel tatsächlich dem Düxel Platz machen werden muss, wird sich erst in den nächsten Jahren herauskristallisieren.</p>
<p>Die Eckdaten:</p>
<ul>
<li>Auflösung: 5x30 Düxel</li>
<li>Stromverbrauch: 0 kW</li>
<li>Bildschirmdiagonale: 30''</li>
<li>Dübcheck &amp; Roe&rsquo;sche Constraint: 100 Dübel</li>
</ul>
]]></content></item><item><title>Twetterhäuschen</title><link>https://digitalitility.com/posts/2013/11/twetterh%C3%A4uschen/</link><pubDate>Wed, 20 Nov 2013 12:27:30 +0100</pubDate><guid>https://digitalitility.com/posts/2013/11/twetterh%C3%A4uschen/</guid><description>The Twetterhäuschen is the world&amp;rsquo;s first Wetterhäuschen for visualizing the sentiment of a specific topic on twitter. It was built on a raspberry pi, a servo controlled by an arduino uno, using node.js in combination with socket.io. You can find the code on github to build your own: https://github.com/sektionschef/twetterhaeuschen
Implementation The Twetterhäuschen has its web form (index.html) to fill a brand or topic of interest The keyword is passed on to the server (app.</description><content type="html"><![CDATA[<p>The Twetterhäuschen is the world&rsquo;s first Wetterhäuschen for visualizing the sentiment of a specific topic on <a href="http://twitter.com/">twitter</a>. It was built on a <a href="http://www.raspberrypi.org/">raspberry pi</a>, a servo controlled by an <a href="http://arduino.cc/">arduino uno</a>, using <a href="http://nodejs.org/">node.js</a> in combination with <a href="http://socket.io/">socket.io</a>. You can find the code on github to build your own: <a href="https://github.com/sektionschef/twetterhaeuschen">https://github.com/sektionschef/twetterhaeuschen</a></p>
<p><figure><img src="Twetterhaeuschen_01.jpg"
         alt="Twetterhaeuschen_01"/>
</figure>

<figure><img src="Twetterhaeuschen_02.jpg"
         alt="Twetterhaeuschen_02"/>
</figure>

<figure><img src="Twetterhaeuschen_03.jpg"
         alt="Twetterhaeuschen_03"/>
</figure>

<figure><img src="Twetterhaeuschen-Frontend.png"
         alt="Twetterhaeuschen Frontend"/>
</figure>
</p>
<h2 id="implementation">Implementation</h2>
<ol>
<li>The Twetterhäuschen has its web form (index.html) to fill a brand or topic of interest</li>
<li>The keyword is passed on to the server (app.js) which takes care of the API calls using the <a href="https://github.com/ciaranj/node-oauth">oauth</a> module. The search is completed with some words to derive a basic level of sentiment, e.g. &ldquo;love&rdquo; or &ldquo;hate&rdquo;</li>
<li>Taking the reach (number of followers) into account, the ratio between good and bad is calculated</li>
<li>The arduino sets the servo between the angle of 60 and 130 in order to move the two characters Sepp and Susi out of the Twetterhäuschen.</li>
<li>Whereas Sepp represents the dark force, Susi acts as a substitute for ecstacy and elation.</li>
</ol>
<p>Here is an explanation in German:</p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube.com/embed/jSNGg0Prsf4" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

]]></content></item><item><title>Animation in the command line - ./animation.sh</title><link>https://digitalitility.com/posts/2012/01/animation-in-the-command-line-./animation.sh/</link><pubDate>Sun, 29 Jan 2012 12:27:30 +0100</pubDate><guid>https://digitalitility.com/posts/2012/01/animation-in-the-command-line-./animation.sh/</guid><description>Why After finding out how much one can do with ffmpeg&amp;hellip; I thought it would be the perfect tool for creating my abstract stop-motion animation I dreamed of for years. What I wanted to realize was simple: combining scenes of a series of high resolution photographs, including images of paintings and digitally edited material with various lengths, framerates exactly timed to a soundtrack.
Ffmpeg is a powerful tool to convert audio and video files (among other things).</description><content type="html"><![CDATA[
<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://player.vimeo.com/video/18348528" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="vimeo video" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>
</div>

<h1 id="why">Why</h1>
<p>After finding out how much one can do with <a href="http://www.ffmpeg.org/" title="http://www.ffmpeg.org/">ffmpeg</a>&hellip; I thought it would be the perfect tool for creating my abstract stop-motion animation I dreamed of for years. What I wanted to realize was simple: combining scenes of a series of high resolution photographs, including images of paintings and digitally edited material with various lengths, framerates exactly timed to a soundtrack.</p>
<p>Ffmpeg is a powerful tool to convert audio and video files (among other things). It allows to define many parameter and enables batch processing videos. What it does not provide is a graphical interface for cutting and editing the files. So I learned some BASH and wrote a script to achieve my goals. All I am working with is a directory where the scenes are stored, a text file which defines the time, the framerate and the position of the individual scenes and the final output video.</p>
<p>The advantages are that I exactly get what I want and that I learned a lot. It&rsquo;s the simple, clear way of editing the project as well as the separation of media and the concept that I really like about this method. The disadvantages are the time until the whole video is rendered - it takes approximately an hour until the HD version of the video is rendered. For this project, I still think that this approach is in fact easier than working with a large-scale video editing software.</p>
<p>The video itself is my personal art project. It features some visual, experimental ideas. It was done on the basis of my own photos and paintings/drawings and simply deals with &ldquo;seeing things&rdquo; as well as how to achieve a flat picture from a real world 3d image. I am messing with colours, perspective, light and movement. In the beginning everything is about an impression of movement using still images. Additionally, the animations of signs and graffiti support the topic of movement and are used to separate certain blocks of scenes. Then, similar geometric forms found on the streets are shown. The exact alignment of the photos emphasizes the similarities of the objects. The next scenes of the animation deal with colours and colour differences that were generated by manipulating the contrast.</p>
<p>The following animations should show a certain difficulty of perceiving depth in the images. The next images continue this idea and visualize the transformation from the three dimensional reality to the flat, two dimensional image of that reality. The animations featuring the rectangles of black tape invert this process by actually projecting a flat rectangle back in the real space. The rectangle is solely visible from the perspective of the camera.</p>
<p><figure><img src="equip.jpg"
         alt="taped rectangle"/>
</figure>

<figure><img src="equip02.jpg"
         alt="taped rectangle"/>
</figure>

<figure><img src="equip03.jpg"
         alt="taped rectangle"/>
</figure>
</p>
<p>Similarly, the images feature how space, a white wall with corners, are reduced to different shades of white. The change of perspective creates different minimalist images. In the paintings the topics are applied practically. It is moreover interesting to see, how these evolve. The wood frame in the end acts as a summary by showing the same object in different states: during the different colours of daylight, with a moving light source and the wood frame moving itself.</p>
<p>I chose the song <em>Mouthpiece</em> by the band <a href="http://www.touchandgorecords.com/bands/band.php?id=22" title="http://www.touchandgorecords.com/bands/band.php?id=22">Shellac</a> as a soundtrack. The song is vital to the film providing the rhythm of the transitions and it is a brilliant song.</p>
<h2 id="manipulating-images">Manipulating Images</h2>
<p>Most of the images need some form of editing or need to be arranged to achieve a proper overlay in order to focus on specific differences in the images and erase the unwanted differences. Some changes are created just by manipulating pictures.</p>
<p>For image manipulation I use the <a href="http://www.gimp.org/" title="http://www.gimp.org/">Gimp</a>. Each scene&rsquo;s frame is one layer and the whole scene can be saved with all layers in the .xcf format. The task of aligning the layers is easy with the right script, <a href="http://registry.gimp.org/node/18961" title="http://registry.gimp.org/node/18961">exact aligner</a>. Just draw a line on two layers to define two identical parts in both images. After running the script from the menu the second line is fitted to the first line - hard to explain, easy to grasp. Usually I crop the canvas a little (in the aspect ratio of 4:3).</p>
<p>Then another wonderful <a href="http://registry.gimp.org/node/15617" title="http://registry.gimp.org/node/15617">script</a> enables me to export all layers as separate .jpg files (I only needed to edit the default filename in the script itself from .png to .jpg). I also changed the Gimp&rsquo;s default .jpg quality settings. The result is a couple of .jpgs in your home folder with the scene&rsquo;s filename and a continuous frame number. The scripts take care of the rest.</p>
<h2 id="first-attempt">First Attempt</h2>
<p>The first task for me was to define a workflow what tasks need to be done, in what sequence, how to organize the files and how to change the parameters in a convenient way. The 3 basic operations I wanted are:</p>
<ul>
<li>Create a new scene with a set of images</li>
<li>Edit parameters of existing scenes</li>
<li>Edit parameters of all scenes at once</li>
</ul>
<p>The basic command for ffmpeg to render a video based on images is something like:</p>
<p><code>ffmpeg -loop_input -f image2 -r &lt;FRAMERATE_SCENE&gt; -i &quot;input_frame_%04d.jpg&quot; -vframes &lt;LENGTH&gt; &quot;output.avi&quot;</code></p>
<p>As a result, the basic parameters are the <strong>framerate</strong> of the scene, its <strong>length</strong> and the <strong>input filename</strong>, which is given as <em>%04d</em>. This means that the format of the number is 4 digits, 0001-9999 (<a href="http://spielwiese.la-evento.com/hokuspokus/" title="http://spielwiese.la-evento.com/hokuspokus/">helpful link</a>). Furthermore, the <a href="http://www.ffmpeg.org/faq.html" title="http://www.ffmpeg.org/faq.html">ffmpeg faq</a> points out that .avi files can be concatenated using the <em>cat</em> command - merging the files with the result of one single video. However, the cat command does not know in which sequence to merge the files. For the correct order of all scenes a <strong>numbering</strong> is needed, which I called „rank&quot;, and this should become part of the filename. The <em>cat</em> command starts with the first number and continues until the last frame. In sum, the framerate, the length and the rank are the parameters which determine the editing of the video file. These parameters should be easily changeable. The only thing which should be invariable is the scene&rsquo;s name.</p>
<p>For easing my task and keeping an overview I wrote these parameters in a separate .csv file (comma separated file). There I can reschedule the scenes, the framerates and the length at once. For rescheduling, sorting, calculating and changing the scenes the .csv file can be imported in open office spreadsheet. The cutlist is in the form of:</p>
<pre tabindex="0"><code>RANK;SCENE;FRAMERATE;LENGTH
0001;abdeckungen;4;30;
0002;radl;4;50;
</code></pre><p>My first version script (you can find in the <a href="http://tutori.alitility.com/doku.php?id=ubuntu:animation_in_the_command_line#one_after_the_other_script" title="ubuntu:animation_in_the_command_line">appendix</a>) begins by asking the only parameter a scene name from the user. The input is then checked if it already exists or not, which determines the subsequent operations. If the input is <em>all</em> all scenes are rendered according to the parameters of the cutlist.</p>
<p>The cutlist file is read for the needed parameters or if the scene is not yet existing these are entered directly to the terminal and written to the cutlist. For new scenes a directory is made, the frames transferred to this directory, resized to the wished size using imagemagick, renamed to include the scenes' rank and rendered. If the rank has changed the filename of all videos is renamed and the scene is rendered according to the new parameters.</p>
<p>In the final block which is run in any case the filenames of all video outputs is checked against the cutlist.csv in order to remove obsolete files, which would mess up the <em>cat</em> command. Then all videos are merged by <em>cat</em> in the sequence of the rank and the soundtrack is added by ffmpeg. Que bello!</p>
<h2 id="picture-in-picture-animation">Picture in Picture Animation</h2>
<p>Soon after finishing my first script and celebrating my success I realized that the end result became a victim of the worst enemy art films have to face - boredom. The scenes were cut one after the other and the proper mojo was missing. What I actually wanted was displaying several scenes at once (picture in picture) in order to emphasize a relationship among them. In <a href="http://www.imagemagick.org/script/index.php" title="http://www.imagemagick.org/script/index.php">imagemagick</a> I found a way of realizing what I wanted using layers. The basic command for this is:</p>
<pre tabindex="0"><code>for i in {1..5}
do
convert -size 1440x1080 xc:black &quot;a_*$i.jpg&quot; -geometry 700x525+383+6 -composite &quot;b_*$i.jpg&quot; -geometry 700x525+13+546 -composite &quot;c_*$i.jpg&quot; -geometry 700x525+728+546 -composite &quot;output_`printf &quot;%04d&quot; $i`.jpg&quot;
done
</code></pre><p>I started all over again, this time letting imagemagick render the frames by arranging several pictures into one. The frames need to be processed individually before I can render a scene. As a consequence every single frame of the final video is rendered in imagemagick and then processed by ffmpeg. The scenes are layers on a 1440×1080 canvas in black color. The output is a frame in the format ffmpeg is able to use. Having each frame rendered takes quite some time! Still, the quality is amazing.</p>
<p>On the basis of this command I came up with a new workflow consisting of 3 separate scripts:</p>
<ul>
<li>rendering the whole video or just parts of it (by defining a frame range in the terminal)</li>
<li>a preview script, for monitoring single scenes (use export of gimp; defining the framerate in the terminal)</li>
<li>importing a scene in my cutlist</li>
</ul>
<p>Like in the first script I use a .csv file for the parameters, which is a little bit expanded now. The difference compared to the cutlist of my first script is a column for the PIP parameter, a category column and frank instead of rank and the endfrank instead of length. The PIP parameter defines where the scene is placed on the canvas. The category just helps me to organize and filter the scenes while editing the .csv file directly but has no impact on the process itself. The biggest difference is frank, the frame the scene appears for the first time in the final video. On the contrast, the rank of the first script was just ordinal. The endfrank is the last frame in the video the scene is shown - this quite helps with the timing when cutting the scenes. The cutlist looks like this:</p>
<pre tabindex="0"><code class="language-csv" data-lang="csv">FRANK;SCENE;FRAMERATE;ENDFRANK;PIP(wxh+w_o+h_o);CATEGORY 50;emergencydahoam;7;600;900x675+980+365;animation_bewegung 275;stiegeberlin;5;650;900x675+40+40;animation_bewegung 700;ubahnstill;8;786;1440x1080+240+0;animation 787;ubahn;8;990;1440x1080+240+0;animation 1000;benettonromdoppelt;5;1195;900x675+980+202;bewegung 1005;benettonrom;5;1200;900x675+40+202;bewegung 1211;kabelsalatrom;5;1471;640x480+1120+560;bewegung 1226;gradeskabelrom;5;1486;640x480+1120+40;bewegung 1253;kabelangelbrom;5;1501;640x480+160+560;bewegung 1268;hinundherrom;5;1522;640x480+160+40;bewegung 1542;abdeckungen;4;1738;900x675+980+365;gleicheformen 1644;gitterfenster;4;1859;900x675+40+40;gleicheformen 1738;malewitschrom;4;1968;900x675+980+40;gleicheformen 1860;fensterneubaugasse;4;2068;900x675+40+365;gleicheformen 2088;dreckradrom;8;2281;900x675+980+202;animation 2088;dreckbamrom;8;2281;900x675+40+202;animation 2302;farbengelbblinkybill;4;2550;900x675+980+202;farbe_gelb 2312;farbengelbvierkant;4;2595;900x675+40+202;farbe_gelb 2550;farbengraumauer;3;2833;900x675+980+202;farbe_grau 2595;farbengraucanvas;4;2880;900x675+40+202;farbe_grau 2833;farbenalles;5;3040;900x675+980+202;farbe 2880;gumpsn;2;3069;900x675+40+202;farbe 3093;radl;8;3274;1440x1080+240+0;animation_bewegung 3290;wienfluss;10;3506;900x675+1200+202;tiefe 3300;meyerrom;10;3536;900x675+240+202;tiefe 3521;andreahandrom;10;3780;900x675+980+202;tiefe 3550;leibalberlin;5;3780;900x675+40+202;animation_tiefe 3794;leopolda;5;4003;640x480+640+40;3d 3824;leopoldb;5;4003;640x480+160+560;3d 3854;leopoldc;5;4003;640x480+1120+560;3d 4014;dreieckroma;5;4223;640x480+640+40;3d 4044;dreieckromb;5;4223;640x480+160+560;3d 4074;dreieckromc;5;4223;640x480+1120+560;3d 4234;balkenbaerberlina;5;4453;640x480+640+40;3d 4264;balkenbaerberlinb;5;4453;640x480+160+560;3d 4294;balkenbaerberlinc;5;4453;640x480+1120+560;3d 4474;oelschranka;2;4570;1440x1080+240+0;perspektive 4570;oelschrankb;5;4860;1440x1080+240+0;perspektive 4884;rechteckb;2;5028;640x480+1120+40;perspektive 4884;rechteckd;2;5028;640x480+1120+560;perspektive 4884;rechtecka;2;5028;640x480+160+40;perspektive 4884;rechteckc;2;5028;640x480+160+560;perspektive 5028;rechteckabcddoppelt;5;5293;640x480+1120+40;perspektive 5028;rechteckabcdvierfach;5;5293;640x480+1120+560;perspektive 5028;rechteckabcd;5;5293;640x480+160+40;perspektive 5028;rechteckabcddreifach;5;5293;640x480+160+560;perspektive 5320;powerhouseberlin;6;5590;900x675+40+40;2d 5320;vogelberlin;6;5590;900x675+980+365;2d 5590;jedermannberlin;4;5840;900x675+40+365;2d 5590;tucholsky;5;5840;900x675+980+40;2d 5886;malereiberlina;2;6376;640x480+640+40;malerei 5966;malereiberlinc;2;6376;640x480+1120+560;malerei 6046;malereiberlinb;2;6376;640x480+160+560;malerei 6376;malereiberlinbstill;5;6511;640x480+160+560;malerei 6376;malereiberlincstill;5;6554;640x480+1120+560;malerei 6376;malereiberlinastill;5;6602;640x480+640+40;malerei 6659;blumenkastldrehenstill;5;6788;640x480+160+560;alles 6716;blumenkastllichtstill;5;6788;640x480+640+40;alles 6770;blumenkastllichtdrehenstill;5;6788;640x480+1120+560;alles 6788;blumenkastldrehenpreludium;7;6806;640x480+160+560;alles 6788;blumenkastllicht;10;7023;640x480+640+40;alles 6788;blumenkastllichtdrehen;7;7023;640x480+1120+560;alles 6806;blumenkastldrehen;7;7023;640x480+160+560;alles
</code></pre><p>I calculated some standard picture in picture positions for arranging the scenes:</p>
<p><figure><img src="animation_04b.png"
         alt="animation_04b" width="100%"/>
</figure>

<figure><img src="animation_03b.png"
         alt="animation_03b" width="100%"/>
</figure>

<figure><img src="animation_04.png"
         alt="animation_04" width="100%"/>
</figure>

<figure><img src="animation_03.png"
         alt="animation_03" width="100%"/>
</figure>

<figure><img src="animation_02b.png"
         alt="animation_02b" width="100%"/>
</figure>

<figure><img src="animation_02.png"
         alt="animation_02" width="100%"/>
</figure>
</p>
<p>here is a flowchart: <figure><img src="flowchart_animation.png"
         alt="Flowchart of animation" width="100%"/>
</figure>
</p>
<h3 id="preview">Preview</h3>
<p>Gimp owns an animation preview function (filters &gt; animation &gt; playback) but I don&rsquo;t really like it. My images have a higher resolution and must be rescaled before viewing the animation and changing the framerate is a pain in the ass. I wrote a script which does the same thing only a bit more convenient. At the same time, it is the first step before importing a scene in my project.</p>
<p>The framerate is set in the terminal as $1 otherwise a default value of 5 is used. The other variables for this little script is the image size and the bitrate of the preview video. After the images have been exported from gimp they are moved from the home directory to the preview directory, resized and renamed. If no images are in the home directory the script processes those of the preview directory so I can experiment with different framerates quickly. The preview directory is emptied if new images have been exported to the home directory. The video itself is created by the basic ffmpeg command for these situations. That&rsquo;s it basically!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#! /bin/bash
</span><span style="color:#75715e"></span>
FRAMERATE<span style="color:#f92672">=</span>$1
<span style="color:#75715e"># can be set as part of the command</span>

BITRATE<span style="color:#f92672">=</span>10000k
LENGTH<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>

PREVIEW_DIRECTORY<span style="color:#f92672">=</span>06_preview
SIZE<span style="color:#f92672">=</span>x1080

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;</span>$FRAMERATE<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">then</span>
   FRAMERATE<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;5&#34;</span>
<span style="color:#66d9ef">fi</span>
<span style="color:#75715e"># sets a default value for framerate</span>

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;`ls ~ | grep &#34;</span>_*.jpg<span style="color:#e6db74">&#34;`&#34;</span> <span style="color:#f92672">]</span>

<span style="color:#66d9ef">then</span>
echo <span style="color:#e6db74">&#34;+++++++++ already exists ++++++&#34;</span>

<span style="color:#66d9ef">else</span>
<span style="color:#75715e">#clean house</span>
rm -f $PREVIEW_DIRECTORY/*.jpg

echo <span style="color:#e6db74">&#34;+++++++++ Copy frames to preview directory ++++++++++&#34;</span>
mv ~/*.jpg $PREVIEW_DIRECTORY

echo <span style="color:#e6db74">&#34;+++++++++ Resize frames ++++++++++&#34;</span>
mogrify -resize $SIZE $PREVIEW_DIRECTORY/frame_*.jpg

<span style="color:#66d9ef">fi</span>

echo <span style="color:#e6db74">&#34;+++++++++++++ Render </span>$SCENE<span style="color:#e6db74"> ++++++++++++&#34;</span>
ffmpeg -y -loop_input -r $FRAMERATE -f image2 -i <span style="color:#e6db74">&#34;</span>$PREVIEW_DIRECTORY<span style="color:#e6db74">/frame_%04d.jpg&#34;</span> -vframes $LENGTH -b $BITRATE -r <span style="color:#ae81ff">25</span> preview.avi

exit
</code></pre></div><h2 id="importing-new-scene-in-project">Importing new scene in project</h2>
<p>In case I liked the preview, it is included in the cutlist and therefore part of the project. The following script accomplishes this task without any woes. It asks for the details and parameters in the terminal and writes them into a new line of the cutlist. Before that the contents of the cutlist are shown in order to have some sort of orientation where to put it. For security reasons, the script also checks if the scene&rsquo;s name is already existing. Additionally, a new directory (named after the scene name) is created, the images are moved there and are also renamed properly by including the scene name.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#! /bin/bash
</span><span style="color:#75715e"></span>
<span style="color:#75715e">###########################################################</span>
CUTLIST<span style="color:#f92672">=</span>cutlist_hobo.csv
PREVIEW_DIRECTORY<span style="color:#f92672">=</span>06_preview

<span style="color:#75715e">###########################################################</span>

echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
echo <span style="color:#e6db74">&#34;Please enter the SCENE&#39;s name:&#34;</span>
echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
read INPUT_SCENE

<span style="color:#75715e"># check if input scene is unique</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;`grep &#34;</span>;<span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span>;<span style="color:#e6db74">&#34; </span>$CUTLIST<span style="color:#e6db74">`&#34;</span> <span style="color:#f92672">]</span>

<span style="color:#66d9ef">then</span>

cat $CUTLIST

echo +++++++++ <span style="color:#e6db74">&#34;Define parameters&#34;</span> ++++++++++
echo <span style="color:#e6db74">&#34;Please enter its FRANK:&#34;</span>
read INPUT_FRANK
echo <span style="color:#e6db74">&#34;Please enter the framerate:&#34;</span>
read INPUT_FRAMERATE
echo <span style="color:#e6db74">&#34;Please enter the last frame&#39;s number:&#34;</span>
read INPUT_LENGTH
echo <span style="color:#e6db74">&#34;Please enter the PIP parameters (wxh+w_o+h_o):&#34;</span>
read INPUT_PIP

echo +++++++++ <span style="color:#e6db74">&#34;Create directory </span>$INPUT_SCENE<span style="color:#e6db74">&#34;</span> ++++++++++
mkdir -p 02_scenes/$INPUT_SCENE

echo +++++++++ <span style="color:#e6db74">&#34;Copy frames to newly created directory&#34;</span> ++++++++++
mv $PREVIEW_DIRECTORY/*.jpg 02_scenes/$INPUT_SCENE

echo +++++++++++++ <span style="color:#e6db74">&#34;Rename by adding the scene&#39;s name&#34;</span> ++++++++++++
<span style="color:#66d9ef">for</span> FILE in 02_scenes/$INPUT_SCENE/frame_*.jpg ;
<span style="color:#66d9ef">do</span>
NEWFILE<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>echo $FILE | sed <span style="color:#e6db74">&#34;s/frame/</span>$INPUT_SCENE<span style="color:#e6db74">\_frame/g&#34;</span><span style="color:#e6db74">`</span> ;
mv <span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> $NEWFILE ;
<span style="color:#66d9ef">done</span>

echo +++++++++++++ <span style="color:#e6db74">&#34;Write variables to cutlist&#34;</span> ++++++++++++
echo <span style="color:#e6db74">&#34;</span>$INPUT_FRANK<span style="color:#e6db74">;</span>$INPUT_SCENE<span style="color:#e6db74">;</span>$INPUT_FRAMERATE<span style="color:#e6db74">;</span>$INPUT_LENGTH<span style="color:#e6db74">;</span>$INPUT_PIP<span style="color:#e6db74">;&#34;</span> &gt;&gt; $CUTLIST

<span style="color:#66d9ef">else</span>
read -p <span style="color:#e6db74">&#34;+++++++++++++ Name of scene is already existing ++++++++++++&#34;</span>

<span style="color:#66d9ef">fi</span>

exit
</code></pre></div><h2 id="script-for-rendering-the-pip-video">Script for rendering the PIP video</h2>
<h3 id="render-framerate-and-length">Render framerate and length</h3>
<p>The first part covers the conversion of my images in frames for the video, i.e. the images are brought to the correct framerate and length. Because of arranging the scenes frame-by-frame, I have to do this by myself and cannot simply tell ffmpeg to deal with it like in the first script. But let&rsquo;s start with one thing after the other.</p>
<p>First, the variables are defined. It is possible to define a frame range when running the script in the terminal, in which the script is processed. For instance, frame 500 to 1000. The default value is frame 1 to frame 7270 which is approximately the end of the soundtrack. The overall framerate I chose is 25 seconds per frame following the PAL standard. The canvas size is 1920×1080 and the bitrate for the final movie is also defined by a variable. Once the video is finished I might render it with a higher bitrate.</p>
<p>Next, each scene&rsquo;s parameters are read from the cutlist: the frank, the length, the framerate and the scene per PIP frame. Additionally, the number of the original frames in the directory is counted. The length is derived by the difference between frank and the end frame of the scene. For matching the strings of scene names, I use the delimiter &ldquo;;&rdquo;, otherwise equal parts of names would be found as well (looking for &ldquo;deck&rdquo; finds scene name &ldquo;deck&rdquo; but also &ldquo;abdeckungen&rdquo;). For debugging, the scripts prints the parameters it finds for each scene.</p>
<p>Now, the mess begins. For clarification, I&rsquo;ll use an example. The basic parameters we need is the length <em>l</em>, how long the scene is displayed i.e. how many frames, and the framerate <em>r</em>, how fast the images change. Furthermore, we also need to know how many images the original animation consists of <em>o</em>.</p>
<pre tabindex="0"><code>r... 10
l... 600
o... 4 (A,B,C,D)
</code></pre><p>Mind the difference between frame and image. Image for me is one of the pictures made for the scene, in the example A-D. Frame for me is one of the pictures the final video consists of, 25 frames per second in my case.</p>
<p>The image has to be copied to a certain amount in order to reach the framerate defined in the cutlist. This amount is calculated by the overall framerate divided by the desired framerate, 25/10 = 2.5. Mind that Bash gives only the integer output of 2. Neglecting the 0.5 (dealing with this later), the image has to be copied once. Afterwards, the second image B has to be copied as well as the remaining images of the animation (C,D). This procedure has to be done until the end frame of 600 is reached. I think this is what my math teacher used to call series and rows.</p>
<p>I realized this function by implementing two loops, the outer loop covering the length count and the inner loop carrying out the framerate copy. The inner loop, called framerate_boost, is starting at 1 and ends at the 25/2 increasing by 1. Once this loop is done for an image it falls back to the outer loop, the length_boost, starting at 0 ending at 600 - 1. The increment of the length_boost must be also 25/2. In the examples the length_boost has the following values: 0,2,4,6&hellip; and 0,5,10,15&hellip; respectively. The loop itself has no function but enables to copy the different images one after the other until the last frame of the scene.</p>
<p>The animation would look like this:</p>
<div>
  <table>
  <tbody><tr><th>Frame</th><th>Image</th><th>Framerate Loop</th><th>Length Loop</th></tr><tr><td>1</td><td>A</td><td>1st frame_boost</td><td rowspan="2">1st length_boost</td></tr><tr><td>2</td><td>A</td><td>2nd frame_boost</td></tr><tr><td>3</td><td>B</td><td>1st frame_boost</td><td rowspan="2">2nd length_boost</td></tr><tr><td>4</td><td>B</td><td>2nd frame_boost</td></tr><tr><td>5</td><td>C</td><td>1st frame_boost</td><td rowspan="2">3rd length_boost</td></tr><tr><td>6</td><td>C</td><td>2nd frame_boost</td></tr><tr><td>7</td><td>D</td><td>1st frame_boost</td><td rowspan="2">4th length_boost</td></tr><tr><td>8</td><td>D</td><td>2nd frame_boost</td></tr><tr><td>9</td><td>A</td><td>1st frame_boost</td><td rowspan="2">5th length_boost</td></tr><tr><td>10</td><td>A</td><td>2nd frame_boost</td></tr><tr><td>11</td><td>B</td><td>1st frame_boost</td><td rowspan="2">6th length_boost</td></tr><tr><td>..</td><td>..</td><td>..</td></tr><tr><td>600</td><td>D</td><td>2nd frame_boost</td><td>300th length_boost</td></tr></tbody>
</table>
</div>
<p>for r&hellip; 5</p>
<div>
  <table>
  <tbody><tr><th>Frame</th><th>Image</th><th>Framerate Loop</th><th>Length Loop</th></tr><tr><td>1</td><td>A</td><td>1st frame_boost</td><td rowspan="5">1st length_boost</td></tr><tr><td>2</td><td>A</td><td>2nd frame_boost</td></tr><tr><td>3</td><td>A</td><td>3rd frame_boost</td></tr><tr><td>4</td><td>A</td><td>4th frame_boost</td></tr><tr><td>5</td><td>A</td><td>5th frame_boost</td></tr><tr><td>6</td><td>B</td><td>1st frame_boost</td><td rowspan="5">2nd length_boost</td></tr><tr><td>7</td><td>B</td><td>2nd frame_boost</td></tr><tr><td>8</td><td>B</td><td>3rd frame_boost</td></tr><tr><td>9</td><td>B</td><td>4th frame_boost</td></tr><tr><td>10</td><td>B</td><td>5th frame_boost</td></tr><tr><td>11</td><td>C</td><td>1st frame_boost</td><td rowspan="2">3rd length_boost</td></tr><tr><td>..</td><td>..</td><td>..</td></tr><tr><td>600</td><td>D</td><td>5th frame_boost</td><td>12th length_boost</td></tr></tbody>
</table>
</div>
<p>the end result could look like this (although it has an infinite loop):</p>
<p>with r = 10
<figure><img src="animation_ball.gif"
         alt="animation_ball" width="100%"/>
</figure>

with r = 5
<figure><img src="animation_ball_slow.gif"
         alt="animation_ball_slow" width="100%"/>
</figure>
</p>
<p>Now, the problem arises that the copy command of the inner loop has to address the correct filenames of the images A-D. For the first frames A, for the next couple of frames B and so on. No wildcards can be used. (otherwise the error notification of <em>directory file not existing</em> shows up). The filenames of the images are in the form of 0001,0002&hellip; Therefore, a frame counter is needed which provides the correct number in the images' filenames. This counter has to be defined in the outer loop, because here the image is selected. I&rsquo;ll use the example from before with r = 10 frames per second.</p>
<p>The length_boost counter, with the increment of 25/10, overall framerate divided by desired framerate, can to rearranged by 0_25/10, 1_25/10, 2_25/10,&hellip; n_25/10. My solution was then to divide the actual length_boost by (25/r + 1), which provides a series of consecutive numbers 1,2,3,..n. This variable can be used to address the images by their filename. Unfortunately, this is not the end of the story. There is the problem that those frame numbers exceeding the number of images (A,B,C,D) are not existing, the numbers &gt;4. When the last image D or 0004 was used the process should start from the beginning, image A or 0001. The 9th frame should be sourced from picture A.</p>
<div>
  <table>
  <tbody><tr><th>Length_boost counter</th><th>Image Number</th><th>Increment</th><th>Rearranging</th><th>$COUNTER</th></tr><tr><td>0</td><td>0001</td><td>+2</td><td>0<em>2</em></td><td>0/2+1=1</td></tr><tr><td>2</td><td>0002</td><td>+2</td><td>12</td><td>2/2+1=2</td></tr><tr><td>4</td><td>0003</td><td>+2</td><td>2<em>2</em></td><td>4/2+1=3</td></tr><tr><td>6</td><td>0004</td><td>+2</td><td>32</td><td>6/2+1=4</td></tr></tbody>
</table>
</div>
<p>I used to overcome this problem with the formula: <em>$counter-o</em>$counter/o_. This formula checks how often the original_frame number is present in the counter. Later (when converting time into numbers of frames), I discovered that there is a built in function, called <a href="http://www.computing.net/answers/unix/remainder-operator/6820.html" title="http://www.computing.net/answers/unix/remainder-operator/6820.html">remainder</a> or modulo_% for bash. Took me a while to fully understand it: 5/2=2 and 5%2=1. The remainder is the left over after a division of two integers (<a href="http://en.wikipedia.org/wiki/Remainder" title="http://en.wikipedia.org/wiki/Remainder">wikipedia</a>). By using the remainder like this <em>$counter%o</em> the resulting series stays inside the limit of the number of images. Basically, this is the same thing as using as the formular above. One problem still remains! For making things even more complicated this does not work for multiples of the number of animation images <em>o</em>, as <em>4%4</em> equals <em>0</em>. A single if condition is able to correct this issue. puh!</p>
<div>
  <table>
  <tbody><tr><th>Length_boost counter</th><th>$COUNTER</th><th>$COUNTER_RESTART</th></tr><tr><td>0</td><td>0/2+1=1</td><td>1%4=1</td></tr><tr><td>2</td><td>2/2+1=2</td><td>2%4=2</td></tr><tr><td>4</td><td>4/2+1=3</td><td>3%4=3</td></tr><tr><td>6</td><td>6/2+1=4</td><td>4%4=0, if condition =4</td></tr><tr><td>8</td><td>8/2+1=5</td><td>5%4=1</td></tr><tr><td>10</td><td>10/2+1=6</td><td>6%4=2</td></tr><tr><td>12</td><td>12/2+1=7</td><td>7%4=3</td></tr><tr><td>14</td><td>14/2+1=8</td><td>8%4=0, if condition =4</td></tr></tbody>
</table>
</div>
<p>Additionally, the copy command must include the scenename and the frame count (the number of the frame it appears in the final video) in the filenames of the frames. The frame count is realized by summing up the loop counters length_boost, framerate_boost. This is the reason why the length_boost starts at zero and not at 1. In order to additionally have the actual frame of the final video the frank -1 is also included. The final result is that each scene is properly positioned due to the frame number in the filename and each scene has the correct value of iteration. In the next step this material will be put together in the correct way, frame by frame.</p>
<h3 id="render-pip-frames">Render pip frames</h3>
<p>The next step is to read out the PIP positions from the cutlist for every scene. On the basis of this information the single frames are created. A temporary directory saves the PIP informations and frames before they are rendered in the next section of the script. This temp file is emptied every run and the frames are newly created.</p>
<p>For every frame a text file is created in which the scene&rsquo;s PIP position is written. The PIP position is in the form of expanding the imagemagick command to process several layers. This means the txt file consists of the parameters which are to be included in the imagemagick command to create the layer for each frame. If the frame does not feature any scenes the text file is empty. An example for a scene&rsquo;s command in a .txt file would be:</p>
<p><code>&lt;filename&gt; -geometry &lt;PIP position&gt; -composite</code></p>
<p>Echo adds these command parts for every scene without using a new line. This is important for including the .txt file into the imagemagick command.</p>
<p>I added the printf command for the creation of the filenames of the final frames because ffmpeg needs them in the form of 0001. I also added the type True Color because otherwise ffmpeg would return the video in grayscale if the first frames were just black screen. Additionally, ffmpeg is processing the images if the file starts from frame 0001 and not 0520.</p>
<h3 id="render-video">Render Video</h3>
<p>The last step is the ffmpeg command for converting images into video. Before we can do that we have to take care of the starting points. Since the rendering takes a lot of time, the script should enable me to see the changes of parameters and timings right away by just presenting a short range of frames, for instance from frame 2000 until frame 2180. In this regard, the soundtrack is especially important, so we need to convert the starting frame into the song&rsquo;s position or to be more precisely time in the form of hh:mm:ss.xxx (hours:minutes:seconds.milliseconds). This task can be done using the remainder we already learned (well, I learned about it here and it took quite some time). Anyway, we can skip the hours because we won&rsquo;t reach these dimensions, the length of my video is about 4 minutes. For the rest one has to know that one second features 25 frames (of course only if the framerate of the final video is 25!). A minute, therefore, features 25_60 frames and one millisecond features 1/40 frames (1000ms=1s=25frames). The starting frame is first checked against the minutes (start_frame/(25_60)). The rest, the remainder %(25_60), is used to derive the seconds /25 and finally the remaining frames are formatted to milliseconds by %(25_60)%25*40. This ensures that the timing of the selection (starting at a certain frame and ending at a certain frame) corresponds exactly to timing of the sound at this position.</p>
<p>The ffmpeg command is then only the simple conversion of my rendered PIP frames to a video file. No special parameters are relevant here. The start and end frame determine the length of the video and the calculated delay of the soundtrack is included.</p>
<h3 id="important-notes">Important notes</h3>
<p>The script&rsquo;s concept is based on the rule that a scene name is only given once&hellip; repeating a scene must result in a new scene name. The names of the scenes should have no underscores either as it is used as a delimiter in the filenames. Total confusion or apocalypse would be the logical consequence.</p>
<p>The <em>0</em> after the wildcard <em>*</em> in the cp command is necessary because otherwise a 0011 and 0001 cannot be distinguished. It is however necessary as the script I use to export gimp&rsquo;s layers as .jpg files uses leading zeros (e.g. 00123). This approach might be a little bit risky as one digit is missing (0150 is found; 1150 is not found). my frame numbers are not that high so I do not run into problems with this solution&hellip; at least not yet.</p>
<p>The framerate and the actual the framerate of the script are different due to the fact that the calculation <em>overall_framerate/desired_framerate</em>(25/10) does not necessarily lead to integer numbers. Bash, luckily, gives only the integer numbers, in our example 2. This is not necessarily a bad thing, because the correct framerate would extend the length of the scene. Having a fixed length of a scene is, however, really important. Furthermore, the final video should have 25 frames per second and therefore the framerate should be a multiple of 25.</p>
<p>Ffmpeg again needs leading zeros for its frame numbers, so conversion from normal numbers (e.g. 123). the printf command is the right tool for this, in the other direction a 0* does the trick, outlined above.</p>
<p>The PIP script is using cut (combined with <em>sed &lsquo;1d&rsquo;</em> for dropping first row) instead of csvtool which I used in my first script. Basically, it provides the same task for me without installing an additional package.</p>
<p>Some of the names I use in my script sound stupid&hellip; I just named it to something that came to my mind ( the name westling for instance originates from the Swedish royals, who married when I was writing this script). But there are many comments for clarifying everything.</p>
<h3 id="the-script">The script</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#! /bin/bash
</span><span style="color:#75715e"></span>
<span style="color:#75715e">##################### Variables ###########################</span>
START_FRAME<span style="color:#f92672">=</span>$1
END_FRAME<span style="color:#f92672">=</span>$2
OVERALL_ASPECT_RATIO<span style="color:#f92672">=</span>1920x1080
OVERALL_FRAMERATE<span style="color:#f92672">=</span><span style="color:#ae81ff">25</span>
<span style="color:#75715e"># important for calculating the number of needed frames of the individual framerate</span>

<span style="color:#75715e"># default values for length</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;</span>$START_FRAME<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">then</span>
   START_FRAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;1&#34;</span>
<span style="color:#66d9ef">fi</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;</span>$END_FRAME<span style="color:#e6db74">&#34;</span> <span style="color:#f92672">]</span>
<span style="color:#66d9ef">then</span>
   END_FRAME<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;7150&#34;</span>
<span style="color:#66d9ef">fi</span>

<span style="color:#75715e">#directories and files</span>
CUTLIST<span style="color:#f92672">=</span>cutlist_hobo.csv
WESTLING<span style="color:#f92672">=</span>03_westling
TEMP<span style="color:#f92672">=</span>04_temp

<span style="color:#75715e">###################################################</span>

echo <span style="color:#e6db74">&#34;##################### Render Framerate and Length ########################&#34;</span>

<span style="color:#75715e"># clean the house</span>
rm -f $WESTLING/*.jpg

<span style="color:#75715e">#### Loop for scene name reading all necessary parameters in cutlist ####</span>
<span style="color:#66d9ef">for</span> SCENE_NAME in <span style="color:#e6db74">`</span>sed <span style="color:#e6db74">&#39;1d&#39;</span> $CUTLIST | cut -d <span style="color:#e6db74">&#39;;&#39;</span> -f <span style="color:#ae81ff">2</span> -<span style="color:#e6db74">`</span>
<span style="color:#75715e"># sed &#39;1d&#39; eliminates the first row of column headers, cut reads the columns using the delimiter &#34;;&#34;</span>
<span style="color:#66d9ef">do</span>

<span style="color:#75715e"># the; around the scene name prevents confusion of strings</span>
FRANK <span style="color:#f92672">()</span>
<span style="color:#f92672">{</span>
grep <span style="color:#e6db74">&#34;;</span>$SCENE_NAME<span style="color:#e6db74">;&#34;</span> $CUTLIST | cut -d <span style="color:#e6db74">&#39;;&#39;</span> -f <span style="color:#ae81ff">1</span> -
<span style="color:#f92672">}</span>
LENGTH <span style="color:#f92672">()</span>
<span style="color:#f92672">{</span>
echo <span style="color:#66d9ef">$((</span> <span style="color:#e6db74">`</span>grep <span style="color:#e6db74">&#34;;</span>$SCENE_NAME<span style="color:#e6db74">;&#34;</span> $CUTLIST | cut -d <span style="color:#e6db74">&#39;;&#39;</span> -f <span style="color:#ae81ff">4</span> -<span style="color:#e6db74">`</span> <span style="color:#f92672">-</span> <span style="color:#e6db74">`</span>FRANK<span style="color:#e6db74">`</span> <span style="color:#66d9ef">))</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e"># length should be a multiple of original_frames and framerate!</span>
<span style="color:#75715e"># length is now in absolute frame numbers of the final video</span>
FRAMERATE <span style="color:#f92672">()</span>
<span style="color:#f92672">{</span>
grep <span style="color:#e6db74">&#34;;</span>$SCENE_NAME<span style="color:#e6db74">;&#34;</span> $CUTLIST | cut -d <span style="color:#e6db74">&#39;;&#39;</span> -f <span style="color:#ae81ff">3</span> -
<span style="color:#f92672">}</span>
SCENE_PIP_PER_FRAME <span style="color:#f92672">()</span> <span style="color:#f92672">{</span> grep <span style="color:#e6db74">&#34;;</span>$SCENE_NAME_PER_FRAME<span style="color:#e6db74">;&#34;</span> $CUTLIST | cut -d <span style="color:#e6db74">&#39;;&#39;</span> -f 5; <span style="color:#f92672">}</span>
<span style="color:#75715e"># this function matches the scenename from the filename with the one in the cutlist and reads the pip parameter accordingly.</span>
ORIGINAL_FRAMES<span style="color:#f92672">()</span>
<span style="color:#f92672">{</span>
ls 02_scenes/<span style="color:#e6db74">&#34;</span>$SCENE_NAME<span style="color:#e6db74">&#34;</span>/<span style="color:#e6db74">&#34;</span>$SCENE_NAME<span style="color:#e6db74">&#34;</span>_frame_*.jpg | wc -w <span style="color:#75715e">#no idea why -l does not work!!!</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e"># counts the number of original frames of the scene</span>

<span style="color:#75715e"># if the scene is not in the defined frame range, its loop is skipped</span>
<span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span><span style="color:#e6db74">`</span>FRANK<span style="color:#e6db74">`</span> &lt; <span style="color:#e6db74">&#34;</span>$START_FRAME<span style="color:#e6db74">&#34;</span><span style="color:#f92672">))</span>
    <span style="color:#66d9ef">then</span>
    <span style="color:#66d9ef">continue</span>
<span style="color:#66d9ef">fi</span>

<span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span><span style="color:#e6db74">`</span>FRANK<span style="color:#e6db74">`</span> &gt; <span style="color:#e6db74">&#34;</span>$END_FRAME<span style="color:#e6db74">&#34;</span><span style="color:#f92672">))</span>
    <span style="color:#66d9ef">then</span>
    break
<span style="color:#66d9ef">fi</span>

<span style="color:#75715e">#echo parameters for debugging</span>
echo <span style="color:#e6db74">&#34;++++ Scene Name: &#34;</span>$SCENE_NAME<span style="color:#e6db74">&#34; ++++&#34;</span>
echo <span style="color:#e6db74">&#34;Frank: `FRANK`&#34;</span>
echo <span style="color:#e6db74">&#34;Length: `LENGTH`&#34;</span>
echo <span style="color:#e6db74">&#34;Framerate: `FRAMERATE`&#34;</span>
echo <span style="color:#e6db74">&#34;Original Frames: `ORIGINAL_FRAMES`&#34;</span>
echo <span style="color:#e6db74">&#34;-------------------------------------------------------&#34;</span>

<span style="color:#75715e">#### first loop - Length Boost ####</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">((</span>LENGTH_BOOST <span style="color:#f92672">=</span> 0;LENGTH_BOOST &lt;<span style="color:#f92672">=</span> <span style="color:#66d9ef">$((</span><span style="color:#e6db74">`</span>LENGTH<span style="color:#e6db74">`</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span><span style="color:#66d9ef">))</span>;LENGTH_BOOST <span style="color:#f92672">=</span> LENGTH_BOOST + <span style="color:#66d9ef">$((</span>$OVERALL_FRAMERATE<span style="color:#f92672">/</span><span style="color:#e6db74">`</span>FRAMERATE<span style="color:#e6db74">`</span><span style="color:#66d9ef">))</span><span style="color:#f92672">))</span> <span style="color:#66d9ef">do</span>
<span style="color:#75715e"># &#34;0&#34; because added to the framerate_boost loop .. length of scene .. increment is derived</span>
<span style="color:#75715e"># length minus one because it starts from 0</span>

COUNTER<span style="color:#f92672">=</span><span style="color:#66d9ef">$((</span>$LENGTH_BOOST <span style="color:#f92672">/</span> <span style="color:#f92672">(</span>$OVERALL_FRAMERATE <span style="color:#f92672">/</span> <span style="color:#e6db74">`</span>FRAMERATE<span style="color:#e6db74">`</span><span style="color:#f92672">)+</span><span style="color:#ae81ff">1</span><span style="color:#66d9ef">))</span>
<span style="color:#75715e"># counts which frame is copied, important for the cp command</span>
<span style="color:#75715e"># does not restart</span>
<span style="color:#75715e"># no idea why brackets are necessary!!</span>

COUNTER_RESTART<span style="color:#f92672">=</span><span style="color:#66d9ef">$((</span>$COUNTER<span style="color:#f92672">%</span><span style="color:#e6db74">`</span>ORIGINAL_FRAMES<span style="color:#e6db74">`</span><span style="color:#66d9ef">))</span>
<span style="color:#75715e"># accomplishes the restart with the remainder</span>

<span style="color:#75715e">#### second loop - Framerate Boost ####</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">((</span>FRAMERATE_BOOST <span style="color:#f92672">=</span> 1;FRAMERATE_BOOST &lt;<span style="color:#f92672">=</span> <span style="color:#66d9ef">$((</span>$OVERALL_FRAMERATE<span style="color:#f92672">/</span><span style="color:#e6db74">`</span>FRAMERATE<span style="color:#e6db74">`</span><span style="color:#66d9ef">))</span>;FRAMERATE_BOOST++<span style="color:#f92672">))</span> <span style="color:#66d9ef">do</span>

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $COUNTER_RESTART <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">]</span>; <span style="color:#66d9ef">then</span>
cp 02_scenes/$SCENE_NAME/<span style="color:#e6db74">${</span>SCENE_NAME<span style="color:#e6db74">}</span>_*0<span style="color:#e6db74">`</span>ORIGINAL_FRAMES<span style="color:#e6db74">`</span>.jpg $WESTLING/<span style="color:#e6db74">${</span>SCENE_NAME<span style="color:#e6db74">}</span>_<span style="color:#66d9ef">$((</span>$LENGTH_BOOST<span style="color:#f92672">+</span>$FRAMERATE_BOOST<span style="color:#f92672">+</span><span style="color:#e6db74">`</span>FRANK<span style="color:#e6db74">`</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#66d9ef">))</span>.jpg
<span style="color:#66d9ef">else</span>
cp 02_scenes/$SCENE_NAME/<span style="color:#e6db74">${</span>SCENE_NAME<span style="color:#e6db74">}</span>_*0<span style="color:#e6db74">${</span>COUNTER_RESTART<span style="color:#e6db74">}</span>.jpg $WESTLING/<span style="color:#e6db74">${</span>SCENE_NAME<span style="color:#e6db74">}</span>_<span style="color:#66d9ef">$((</span>$LENGTH_BOOST<span style="color:#f92672">+</span>$FRAMERATE_BOOST<span style="color:#f92672">+</span><span style="color:#e6db74">`</span>FRANK<span style="color:#e6db74">`</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#66d9ef">))</span>.jpg
<span style="color:#66d9ef">fi</span>
<span style="color:#75715e"># the 0 of the cp command after the wildcard is risky, but not more than 2 digits</span>
<span style="color:#75715e"># additionally to the length und framerate boost the actual position (framenumber), i called it frank, of the final video is added, the final position is written in the filename for the next stage.</span>

<span style="color:#66d9ef">done</span> <span style="color:#75715e"># end FRAMERATE_BOOST</span>
<span style="color:#66d9ef">done</span> <span style="color:#75715e"># end LENGTH_BOOST</span>

<span style="color:#66d9ef">done</span> <span style="color:#75715e"># end loop SCENE_NAME</span>

echo <span style="color:#e6db74">&#34;########################### Render PIP Frames ##############################&#34;</span>
<span style="color:#75715e"># find scenename and then read pip parameters for each frame</span>

<span style="color:#75715e"># clean the house</span>
rm -f $TEMP/*.txt <span style="color:#75715e"># -f prevents errors of already empty directories</span>
rm -f $TEMP/*.jpg

<span style="color:#66d9ef">for</span> <span style="color:#f92672">((</span>i<span style="color:#f92672">=</span>$START_FRAME;i&lt;<span style="color:#f92672">=</span>$END_FRAME;i++<span style="color:#f92672">))</span>
<span style="color:#66d9ef">do</span>
echo -n <span style="color:#e6db74">&#34;&#34;</span> &gt;&gt; <span style="color:#e6db74">&#34;</span>$TEMP<span style="color:#e6db74">/temp_</span><span style="color:#e6db74">${</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">.txt&#34;</span>
<span style="color:#75715e"># if frame is missing a scene, just leave it out</span>
echo <span style="color:#e6db74">&#34;frame number: </span>$i<span style="color:#e6db74"> until </span>$END_FRAME<span style="color:#e6db74">&#34;</span>

<span style="color:#66d9ef">for</span> SCENE_NAME_PER_FRAME in <span style="color:#e6db74">`</span>ls $WESTLING | grep <span style="color:#e6db74">&#34;.*_</span>$i<span style="color:#e6db74">.jpg&#34;</span> | cut -d <span style="color:#e6db74">&#39;_&#39;</span> -f 1<span style="color:#e6db74">`</span>
<span style="color:#66d9ef">do</span>
<span style="color:#75715e"># loop for all frames of the final video and the second loop for all scene names, which already have rendered frames. scenename is read from the filename.</span>

echo -n <span style="color:#e6db74">&#34;</span>$WESTLING<span style="color:#e6db74">/</span><span style="color:#e6db74">${</span>SCENE_NAME_PER_FRAME<span style="color:#e6db74">}</span><span style="color:#e6db74">_</span><span style="color:#e6db74">${</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">.jpg -geometry `SCENE_PIP_PER_FRAME` -composite &#34;</span> &gt;&gt; <span style="color:#e6db74">&#34;</span>$TEMP<span style="color:#e6db74">/temp_</span><span style="color:#e6db74">${</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">.txt&#34;</span>
<span style="color:#75715e"># the whole thing is put in a temp file for each frame; correctly formatted for the imagemagick command</span>
<span style="color:#75715e"># the -n tells echo not to use a new line parameter!!</span>

<span style="color:#66d9ef">done</span> <span style="color:#75715e"># end scene_name_pip_frame</span>

convert -type TrueColor -size $OVERALL_ASPECT_RATIO xc:black <span style="color:#e6db74">`</span>cat <span style="color:#e6db74">&#34;</span>$TEMP<span style="color:#e6db74">/temp_</span><span style="color:#e6db74">${</span>i<span style="color:#e6db74">}</span><span style="color:#e6db74">.txt&#34;</span><span style="color:#e6db74">`</span> <span style="color:#e6db74">&#34;</span>$TEMP<span style="color:#e6db74">/output_`printf &#34;</span>%04d<span style="color:#e6db74">&#34; </span><span style="color:#66d9ef">$((</span> $i <span style="color:#f92672">-</span> $START_FRAME <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">))</span><span style="color:#e6db74">`.jpg&#34;</span>
<span style="color:#75715e"># cat reads the temporary file and completes the command inside the loop. echo would just return the filename</span>
<span style="color:#75715e"># the usage of printf is necessary for ffmpeg in the next step</span>
<span style="color:#75715e"># type Truecolor explicitly needed, otherwise first black frame is saved in grayscale turning the whole video grayscale</span>
<span style="color:#75715e"># the term $(( $i - $START_FRAME + 1 )) is needed to always start counting from 0001 (the way ffmpeg requires it) even if the first frame is &gt;1</span>

<span style="color:#66d9ef">done</span> <span style="color:#75715e"># end frames</span>

echo <span style="color:#e6db74">&#34;################ Render Video ######################&#34;</span>

DELAY_FROM_START_FRAME <span style="color:#f92672">()</span>
<span style="color:#f92672">{</span>
printf <span style="color:#e6db74">&#34;00:%02d:%02d.%03d\n&#34;</span> <span style="color:#66d9ef">$((</span>$START_FRAME<span style="color:#f92672">/</span>$OVERALL_FRAMERATE<span style="color:#f92672">/</span><span style="color:#ae81ff">60</span><span style="color:#66d9ef">))</span> <span style="color:#66d9ef">$((</span>$START_FRAME<span style="color:#f92672">%(</span>$OVERALL_FRAMERATE<span style="color:#f92672">*</span><span style="color:#ae81ff">60</span><span style="color:#f92672">)/</span>$OVERALL_FRAMERATE<span style="color:#66d9ef">))</span> <span style="color:#66d9ef">$((</span>$START_FRAME<span style="color:#f92672">%(</span>$OVERALL_FRAMERATE<span style="color:#f92672">*</span><span style="color:#ae81ff">60</span><span style="color:#f92672">)%</span>$OVERALL_FRAMERATE<span style="color:#f92672">*</span><span style="color:#ae81ff">1000</span><span style="color:#f92672">/</span>$OVERALL_FRAMERATE<span style="color:#66d9ef">))</span>
<span style="color:#f92672">}</span>
<span style="color:#75715e"># brings the start_frame in the format mm:ss.xxx, this is needed for the audio</span>
<span style="color:#75715e"># 5/2=2 but 5%2=1, gives the remainder</span>
<span style="color:#75715e"># printf &#34;%02d:%02d.%03d\n&#34; $(($f/25/60)) $(($f%(25*60)/25)) $(($f%(25*60)%25*40))</span>

<span style="color:#75715e"># easy mpeg2 version</span>
<span style="color:#75715e">#ffmpeg -y -f image2 -i &#34;$TEMP/output_%04d.jpg&#34; -vframes $(($END_FRAME-$START_FRAME)) -r $OVERALL_FRAMERATE -b 10000k -ss `DELAY_FROM_START_FRAME` -i &#34;shellac_mouthpiece.wav&#34; -acodec copy &#34;animation.avi&#34;</span>

<span style="color:#75715e"># HD .mp4 version</span>
ffmpeg -y -f image2 -i <span style="color:#e6db74">&#34;</span>$TEMP<span style="color:#e6db74">/output_%04d.jpg&#34;</span> -ss <span style="color:#e6db74">`</span>DELAY_FROM_START_FRAME<span style="color:#e6db74">`</span> -i <span style="color:#e6db74">&#34;shellac_mouthpiece.wav&#34;</span> -vframes <span style="color:#66d9ef">$((</span>$END_FRAME<span style="color:#f92672">-</span>$START_FRAME<span style="color:#66d9ef">))</span> -vcodec libx264 -vpre slow -crf <span style="color:#ae81ff">22</span> -r $OVERALL_FRAMERATE -threads <span style="color:#ae81ff">0</span> -acodec libfaac -ab 320k -ar <span style="color:#ae81ff">44100</span> -ac <span style="color:#ae81ff">2</span> <span style="color:#e6db74">&#34;animation.mp4&#34;</span>

<span style="color:#75715e"># -ss 00:00:002 start at (before the input file!) and -t 00:00:001 length</span>
<span style="color:#75715e"># -loop_input not needed</span>

exit
</code></pre></div><h2 id="appendix">Appendix</h2>
<p>ONE AFTER THE OTHER SCRIPT</p>
<p>It is the first I wrote, so please be careful. Corrections or optimizations are welcome. The programs used are: csvtool, imagemagick, ffmpeg.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#! /bin/bash
</span><span style="color:#75715e"></span>
<span style="color:#75715e"># variabels</span>
BITRATE<span style="color:#f92672">=</span>600k
HEIGHT<span style="color:#f92672">=</span>x1080
<span style="color:#75715e"># sets the absolute height</span>
FRAMERATE_END<span style="color:#f92672">=</span><span style="color:#ae81ff">24</span>
echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
echo <span style="color:#e6db74">&#34;Please enter the SCENE&#39;s name or render all videos at once by typing all:&#34;</span>
echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
read INPUT_SCENE

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $INPUT_SCENE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;all&#34;</span> <span style="color:#f92672">]</span>
<span style="color:#75715e">################################################## BLOCK 01 #############################################################</span>
   <span style="color:#66d9ef">then</span>
   echo +++++++++++++ <span style="color:#e6db74">&#34;All scenes are processed&#34;</span> ++++++++++++
   echo +++++++++++++ <span style="color:#e6db74">&#34;Reading parameters&#34;</span> ++++++++++++
   <span style="color:#66d9ef">for</span> ALL_SCENES in <span style="color:#e6db74">`</span>csvtool drop <span style="color:#ae81ff">1</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">2</span> -<span style="color:#e6db74">`</span>;
   <span style="color:#66d9ef">do</span>
   RANK_ALL <span style="color:#f92672">()</span>
   <span style="color:#f92672">{</span>
   grep <span style="color:#e6db74">&#34;</span>$ALL_SCENES<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">1</span> -
   <span style="color:#f92672">}</span>
   FRAMERATE_ALL <span style="color:#f92672">()</span>
   <span style="color:#f92672">{</span>
   grep <span style="color:#e6db74">&#34;</span>$ALL_SCENES<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">3</span> -
   <span style="color:#f92672">}</span>
   LENGTH_ALL <span style="color:#f92672">()</span>
   <span style="color:#f92672">{</span>
   grep <span style="color:#e6db74">&#34;</span>$ALL_SCENES<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">4</span> -
   <span style="color:#f92672">}</span>
   echo <span style="color:#e6db74">&#34;scene = </span>$ALL_SCENES<span style="color:#e6db74">&#34;</span>
   echo <span style="color:#e6db74">&#34;rank = `RANK_ALL`&#34;</span>
   echo <span style="color:#e6db74">&#34;framerate = `FRAMERATE_ALL`&#34;</span>
   echo <span style="color:#e6db74">&#34;length = `LENGTH_ALL`&#34;</span>
   <span style="color:#75715e"># warning about too many arguments, because finding lots of files?? but it works</span>
   blod <span style="color:#f92672">()</span>
   <span style="color:#f92672">{</span>
   find ./02_scenes/$ALL_SCENES -name <span style="color:#e6db74">`</span>RANK_ALL<span style="color:#e6db74">`</span>_<span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span>*
   <span style="color:#f92672">}</span>
   <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">`</span>blod<span style="color:#e6db74">`</span> <span style="color:#f92672">]</span>
   <span style="color:#75715e"># if the rank is not the same with the one in the cutlist it has to be updated</span>
     <span style="color:#66d9ef">then</span>
     echo +++++++++++++ <span style="color:#e6db74">&#34;Rename </span>$ALL_SCENES<span style="color:#e6db74"> by updating its name and rank&#34;</span> ++++++++++++
     <span style="color:#66d9ef">for</span> FILE in 02_scenes/$ALL_SCENES/*frame*.jpg ;
        <span style="color:#66d9ef">do</span>
        NEWFILE <span style="color:#f92672">()</span>
        <span style="color:#f92672">{</span>
        echo $FILE | sed <span style="color:#e6db74">&#34;s/</span><span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span><span style="color:#e6db74">\/.*_.*_frame/</span><span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span><span style="color:#e6db74">\/`RANK_ALL`\_</span><span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span><span style="color:#e6db74">\_frame/g&#34;</span>
        <span style="color:#f92672">}</span>
        mv <span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> <span style="color:#e6db74">`</span>NEWFILE<span style="color:#e6db74">`</span> ;
        <span style="color:#66d9ef">done</span>

  <span style="color:#75715e">#paths need to be preserved! wildcards with .* - no idea why!</span>
  <span style="color:#75715e">#frame_* instead of more general *.jpgs because there are also the original photos in the directory</span>
   <span style="color:#66d9ef">fi</span>

   echo +++++++++++++ <span style="color:#e6db74">&#34;Render scene </span>$ALL_SCENES<span style="color:#e6db74">&#34;</span> ++++++++++++
   ffmpeg -y -loop_input -f image2 -r <span style="color:#e6db74">`</span>FRAMERATE_ALL<span style="color:#e6db74">`</span> -i <span style="color:#e6db74">&#34;02_scenes/</span>$ALL_SCENES<span style="color:#e6db74">/`RANK_ALL`_</span><span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span><span style="color:#e6db74">_frame_%04d.jpg&#34;</span> -b $BITRATE -r $FRAMERATE_END -vframes <span style="color:#e6db74">`</span>LENGTH_ALL<span style="color:#e6db74">`</span> <span style="color:#e6db74">&#34;03_output/`RANK_ALL`_</span><span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span><span style="color:#e6db74">_output.avi&#34;</span>
   <span style="color:#66d9ef">done</span>
   <span style="color:#75715e"># {} are necessary to preserve the following underscore</span>
   <span style="color:#75715e"># -r framerate needs to be set before the input parameter</span>
   <span style="color:#75715e"># the framerate of the output is necessary to keep the framerate differences of the scenes</span>

   <span style="color:#66d9ef">else</span>
     <span style="color:#75715e"># if scene not in cutlist; ask for parameters, copy frames and write to cutlist</span>
   <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;`grep &#34;</span>;<span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span>;<span style="color:#e6db74">&#34; cutlist.csv`&#34;</span> <span style="color:#f92672">]</span>
   <span style="color:#75715e">################################################## BLOCK 02 #############################################################</span>
   <span style="color:#75715e"># semicolon prevents the matching of incomplete (parts of) scene names for instance &#34;bdeckunge&#34; instead of &#34;abdeckungen&#34;</span>
   <span style="color:#75715e"># for condition (-z (string is null) -n (string is not null))</span>
      <span style="color:#66d9ef">then</span>
      echo +++++++++++++ <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74"> is not existing ... creation initialized&#34;</span> ++++++++++++

      echo +++++++++++++ <span style="color:#e6db74">&#34;Have you cut the frames of </span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74"> to 4:3 aspect ratio?&#34;</span> ++++++++++++
      read -p <span style="color:#e6db74">&#34;Of course I did!&#34;</span>

      echo +++++++++ <span style="color:#e6db74">&#34;Define parameters&#34;</span> ++++++++++
      echo <span style="color:#e6db74">&#34;Please enter its RANK (4 digits):&#34;</span>
      read INPUT_RANK
      echo <span style="color:#e6db74">&#34;Please enter the framerate:&#34;</span>
      read INPUT_FRAMERATE
      echo <span style="color:#e6db74">&#34;Please enter the length in number of frames:&#34;</span>
      read INPUT_LENGTH

      echo +++++++++ <span style="color:#e6db74">&#34;Create directory for scene&#34;</span> ++++++++++
      mkdir -p 02_scenes/$INPUT_SCENE
      <span style="color:#75715e"># if directory is already existing, no error is given due to the -p</span>

      echo +++++++++ <span style="color:#e6db74">&#34;Copy frames to newly created directory&#34;</span> ++++++++++
      <span style="color:#75715e"># should be 4:3</span>
      mv ~/*.jpg 02_scenes/$INPUT_SCENE

      echo +++++++++ <span style="color:#e6db74">&#34;Resize frames&#34;</span> ++++++++++
      mogrify -resize $HEIGHT 02_scenes/$INPUT_SCENE/frame_*.jpg
      <span style="color:#75715e"># only frames, to prevent original photos;</span>
      <span style="color:#75715e"># imagemagick is used for this</span>

      echo +++++++++++++ <span style="color:#e6db74">&#34;Rename by adding the scene&#39;s name and rank&#34;</span> ++++++++++++
      <span style="color:#75715e"># if the name is not congruent with the entries of the cutlist; rank is necessary for the order of the cat command later on</span>
      <span style="color:#75715e"># only frames, to prevent original photos</span>
      <span style="color:#66d9ef">for</span> FILE in 02_scenes/$INPUT_SCENE/frame_*.jpg ;
      <span style="color:#66d9ef">do</span>
      NEWFILE<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>echo $FILE | sed <span style="color:#e6db74">&#34;s/frame/</span>$INPUT_RANK<span style="color:#e6db74">\_</span>$INPUT_SCENE<span style="color:#e6db74">\_frame/g&#34;</span><span style="color:#e6db74">`</span> ;
      mv <span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> $NEWFILE ;
      <span style="color:#66d9ef">done</span>

      echo +++++++++++++ <span style="color:#e6db74">&#34;Render </span>$SCENE<span style="color:#e6db74">&#34;</span> ++++++++++++
      ffmpeg -loop_input -f image2 -r $INPUT_FRAMERATE -i <span style="color:#e6db74">&#34;02_scenes/</span>$INPUT_SCENE<span style="color:#e6db74">/</span><span style="color:#e6db74">${</span>INPUT_RANK<span style="color:#e6db74">}</span><span style="color:#e6db74">_</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">_frame_%04d.jpg&#34;</span> -b $BITRATE -r $FRAMERATE_END -vframes $INPUT_LENGTH <span style="color:#e6db74">&#34;03_output/</span><span style="color:#e6db74">${</span>INPUT_RANK<span style="color:#e6db74">}</span><span style="color:#e6db74">_</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">_output.avi&#34;</span>
      <span style="color:#75715e"># {} are necessary to preserve the following underscore</span>
      <span style="color:#75715e"># no overwrite (-y) needed</span>
      <span style="color:#75715e"># the framerate of the output is necessary to keep the framerate differences of the scenes</span>

      echo +++++++++++++ <span style="color:#e6db74">&#34;Write variables to cutlist.csv&#34;</span> ++++++++++++
      echo <span style="color:#e6db74">&#34;</span>$INPUT_RANK<span style="color:#e6db74">;</span>$INPUT_SCENE<span style="color:#e6db74">;</span>$INPUT_FRAMERATE<span style="color:#e6db74">;</span>$INPUT_LENGTH<span style="color:#e6db74">;&#34;</span> &gt;&gt; cutlist.csv
      read -p <span style="color:#e6db74">&#34;Done!&#34;</span>
      <span style="color:#75715e"># as a last step after everything was successful to prevent errors in the cutlist</span>

    <span style="color:#75715e"># if scene already in the cutlist</span>
    <span style="color:#66d9ef">else</span>
    <span style="color:#75715e">################################################## BLOCK 03 #############################################################</span>
    echo +++++++++++++ <span style="color:#e6db74">&#34;</span>$INPUT_SCENE<span style="color:#e6db74"> is already existing&#34;</span> ++++++++++++
    echo +++++++++++++ <span style="color:#e6db74">&#34;Read defined parameters of </span>$INPUT_SCENE<span style="color:#e6db74">&#34;</span> ++++++++++++
    <span style="color:#75715e"># Define Functions RANK, FRAMERATE, LENGTH by reading cutlist.csv</span>
    RANK <span style="color:#f92672">()</span>
    <span style="color:#f92672">{</span>
    grep <span style="color:#e6db74">&#34;</span>$INPUT_SCENE<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">1</span> -
    <span style="color:#f92672">}</span>
    FRAMERATE <span style="color:#f92672">()</span>
    <span style="color:#f92672">{</span>
    grep <span style="color:#e6db74">&#34;</span>$INPUT_SCENE<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">3</span> -
    <span style="color:#f92672">}</span>
    LENGTH <span style="color:#f92672">()</span>
    <span style="color:#f92672">{</span>
    grep <span style="color:#e6db74">&#34;</span>$INPUT_SCENE<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">4</span> -
    <span style="color:#f92672">}</span>
    echo <span style="color:#e6db74">&#34;scene = </span>$INPUT_SCENE<span style="color:#e6db74">&#34;</span>
    echo <span style="color:#e6db74">&#34;rank = `RANK`&#34;</span>
    echo <span style="color:#e6db74">&#34;framerate = `FRAMERATE`&#34;</span>
    echo <span style="color:#e6db74">&#34;length = `LENGTH`&#34;</span>
    echo +++++++++++++ <span style="color:#e6db74">&#34; The rank of </span>$INPUT_SCENE<span style="color:#e6db74"> changed ... renaming &#34;</span> ++++++++++++

    <span style="color:#75715e"># warning about too many arguments, because finding lots of files?? but it works</span>
    blod <span style="color:#f92672">()</span>
    <span style="color:#f92672">{</span>
    find ./02_scenes/$INPUT_SCENE -name <span style="color:#e6db74">`</span>RANK<span style="color:#e6db74">`</span>_<span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span>*
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">`</span>blod<span style="color:#e6db74">`</span> <span style="color:#f92672">]</span>
    <span style="color:#75715e"># if the rank is not matching the one of the cutlist, it needs to be changed</span>
     <span style="color:#66d9ef">then</span>
     echo +++++++++++++ <span style="color:#e6db74">&#34;Rename </span>$INPUT_SCENE<span style="color:#e6db74"> by updating its name and rank&#34;</span> ++++++++++++
     <span style="color:#66d9ef">for</span> FILE in 02_scenes/$INPUT_SCENE/*frame*.jpg ;
        <span style="color:#66d9ef">do</span>
        NEWFILE <span style="color:#f92672">()</span>
        <span style="color:#f92672">{</span>
        echo $FILE | sed <span style="color:#e6db74">&#34;s/</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">\/.*_.*_frame/</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">\/`RANK`\_</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">\_frame/g&#34;</span>
        <span style="color:#f92672">}</span>
        mv <span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> <span style="color:#e6db74">`</span>NEWFILE<span style="color:#e6db74">`</span> ;
        <span style="color:#66d9ef">done</span>
    <span style="color:#66d9ef">fi</span>
    echo +++++++++++++ <span style="color:#e6db74">&#34;Render </span>$SCENE<span style="color:#e6db74">&#34;</span> ++++++++++++
    ffmpeg -loop_input -f image2 -r <span style="color:#e6db74">`</span>FRAMERATE<span style="color:#e6db74">`</span> -i <span style="color:#e6db74">&#34;02_scenes/</span>$INPUT_SCENE<span style="color:#e6db74">/`RANK`_</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">_frame_%04d.jpg&#34;</span> -b $BITRATE -r $FRAMERATE_END -vframes <span style="color:#e6db74">`</span>LENGTH<span style="color:#e6db74">`</span> <span style="color:#e6db74">&#34;03_output/`RANK`_</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">_output.avi&#34;</span>
    <span style="color:#75715e"># {} are necessary to preserve the following underscore</span>
    <span style="color:#75715e"># the framerate of the output is necessary to keep the framerate differences of the scenes</span>
    <span style="color:#66d9ef">fi</span>
<span style="color:#66d9ef">fi</span>

<span style="color:#75715e">################################################## FINAL BLOCK #############################################################</span>

echo +++++++++ <span style="color:#e6db74">&#34;Remove expired output videos&#34;</span> ++++++++++
<span style="color:#75715e"># remove expired output videos, otherwise cat adds them to the final file</span>
<span style="color:#66d9ef">for</span> I in 03_output/*_output.avi
    <span style="color:#66d9ef">do</span>
    temp<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>echo <span style="color:#e6db74">&#34;</span>$I<span style="color:#e6db74">&#34;</span> | cut -c 11- | cut -d <span style="color:#e6db74">&#39;_&#39;</span> -f 1-2 | sed  <span style="color:#e6db74">&#34;s/_/;/g&#34;</span><span style="color:#e6db74">`</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">`</span>grep $temp cutlist.csv<span style="color:#e6db74">`</span> <span style="color:#f92672">]</span>
        <span style="color:#66d9ef">then</span>
        echo delete $I ???
        rm -i $I
    <span style="color:#66d9ef">fi</span>
<span style="color:#66d9ef">done</span>
<span style="color:#75715e"># the ls gives the path, cut removes the same path on the 11th digit and passes on the rest, cut separates the output at the &#39;_&#39; sign (recognizes fields) and provides the first two fields, sed is substitutes the &#39;_&#39; with a semicolon as used in the cutlist, and finally this string is looked up in the cutlist</span>

echo +++++++++ <span style="color:#e6db74">&#34;Merge all videos&#34;</span> ++++++++++
cat 03_output/*output.avi &gt; 03_output/output_video.avi
<span style="color:#75715e"># the rank must be correct for the sequence of the scenes</span>

echo +++++++++++ <span style="color:#e6db74">&#34;Add sound&#34;</span> +++++++++++
ffmpeg -y -shortest -i 03_output/output_video.avi -vcodec copy  -b $BITRATE -r $FRAMERATE_END -i 03_output/output_sound.mp3 -acodec copy <span style="color:#e6db74">&#34;invent_a_fire.avi&#34;</span>
<span style="color:#75715e"># should be a formality, the shortest input ends the the file</span>
exit
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># ! /bin/bash</span>

<span style="color:#75715e"># variabels</span>

BITRATE<span style="color:#f92672">=</span>600k HEIGHT<span style="color:#f92672">=</span>x1080

<span style="color:#75715e"># sets the absolute height</span>

FRAMERATE_END<span style="color:#f92672">=</span><span style="color:#ae81ff">24</span> echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ echo <span style="color:#e6db74">&#34;Please enter the SCENE&#39;s name or render all videos at once by typing all:&#34;</span> echo ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ read INPUT_SCENE

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> $INPUT_SCENE <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;all&#34;</span> <span style="color:#f92672">]</span>

<span style="color:#75715e">## ############################################ BLOCK 01</span>

<span style="color:#66d9ef">then</span> echo +++++++++++++ <span style="color:#e6db74">&#34;All scenes are processed&#34;</span> ++++++++++++ echo +++++++++++++ <span style="color:#e6db74">&#34;Reading parameters&#34;</span> ++++++++++++ <span style="color:#66d9ef">for</span> ALL_SCENES in <span style="color:#e6db74">`</span>csvtool drop <span style="color:#ae81ff">1</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">2</span> -<span style="color:#e6db74">`</span>; <span style="color:#66d9ef">do</span> RANK_ALL <span style="color:#f92672">()</span> <span style="color:#f92672">{</span> grep <span style="color:#e6db74">&#34;</span>$ALL_SCENES<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">1</span> - <span style="color:#f92672">}</span> FRAMERATE_ALL <span style="color:#f92672">()</span> <span style="color:#f92672">{</span> grep <span style="color:#e6db74">&#34;</span>$ALL_SCENES<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">3</span> - <span style="color:#f92672">}</span> LENGTH_ALL <span style="color:#f92672">()</span> <span style="color:#f92672">{</span> grep <span style="color:#e6db74">&#34;</span>$ALL_SCENES<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">4</span> - <span style="color:#f92672">}</span> echo <span style="color:#e6db74">&#34;scene = </span>$ALL_SCENES<span style="color:#e6db74">&#34;</span> echo <span style="color:#e6db74">&#34;rank = `RANK_ALL`&#34;</span> echo <span style="color:#e6db74">&#34;framerate = `FRAMERATE_ALL`&#34;</span> echo <span style="color:#e6db74">&#34;length = `LENGTH_ALL`&#34;</span>

<span style="color:#75715e"># warning about too many arguments, because finding lots of files?? but it works</span>

blod <span style="color:#f92672">()</span> <span style="color:#f92672">{</span> find ./02_scenes/$ALL_SCENES -name <span style="color:#e6db74">`</span>RANK_ALL<span style="color:#e6db74">`</span>_<span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span>* <span style="color:#f92672">}</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">`</span>blod<span style="color:#e6db74">`</span> <span style="color:#f92672">]</span>

<span style="color:#75715e"># if the rank is not the same with the one in the cutlist it has to be updated</span>

<span style="color:#66d9ef">then</span> echo +++++++++++++ <span style="color:#e6db74">&#34;Rename </span>$ALL_SCENES<span style="color:#e6db74"> by updating its name and rank&#34;</span> ++++++++++++ <span style="color:#66d9ef">for</span> FILE in 02_scenes/$ALL_SCENES/_frame_.jpg ; <span style="color:#66d9ef">do</span> NEWFILE <span style="color:#f92672">()</span> <span style="color:#f92672">{</span> echo $FILE | sed <span style="color:#e6db74">&#34;s/</span><span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span><span style="color:#e6db74">\/.*_.*_frame/</span><span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span><span style="color:#e6db74">\/`RANK_ALL`\_</span><span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span><span style="color:#e6db74">_frame/g&#34;</span> <span style="color:#f92672">}</span> mv <span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> <span style="color:#e6db74">`</span>NEWFILE<span style="color:#e6db74">`</span> ; <span style="color:#66d9ef">done</span>


<span style="color:#75715e"># paths need to be preserved! wildcards with .* - no idea why!</span>

<span style="color:#75715e"># frame __instead of more general_ .jpgs because there are also the original photos in the directory</span>

<span style="color:#66d9ef">fi</span>

echo +++++++++++++ <span style="color:#e6db74">&#34;Render scene </span>$ALL_SCENES<span style="color:#e6db74">&#34;</span> ++++++++++++ ffmpeg -y -loop_input -f image2 -r <span style="color:#e6db74">`</span>FRAMERATE_ALL<span style="color:#e6db74">`</span> -i <span style="color:#e6db74">&#34;02_scenes/</span>$ALL_SCENES<span style="color:#e6db74">/`RANK_ALL`_</span><span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span><span style="color:#e6db74">_frame_%04d.jpg&#34;</span> -b $BITRATE -r $FRAMERATE_END -vframes <span style="color:#e6db74">`</span>LENGTH_ALL<span style="color:#e6db74">`</span> <span style="color:#e6db74">&#34;03_output/`RANK_ALL`_</span><span style="color:#e6db74">${</span>ALL_SCENES<span style="color:#e6db74">}</span><span style="color:#e6db74">_output.avi&#34;</span> <span style="color:#66d9ef">done</span>

<span style="color:#75715e"># {} are necessary to preserve the following underscore</span>

<span style="color:#75715e"># -r framerate needs to be set before the input parameter</span>

<span style="color:#75715e"># the framerate of the output is necessary to keep the framerate differences of the scenes</span>

<span style="color:#66d9ef">else</span>

<span style="color:#75715e"># if scene not in cutlist; ask for parameters, copy frames and write to cutlist</span>

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">&#34;`grep &#34;</span>;<span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span>;<span style="color:#e6db74">&#34; cutlist.csv`&#34;</span> <span style="color:#f92672">]</span>

<span style="color:#75715e">## ############################################ BLOCK 02</span>

<span style="color:#75715e"># semicolon prevents the matching of incomplete (parts of) scene names for instance &#34;bdeckunge&#34; instead of &#34;abdeckungen&#34;</span>

<span style="color:#75715e"># for condition (-z (string is null) -n (string is not null))</span>

<span style="color:#66d9ef">then</span> echo +++++++++++++ <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74"> is not existing ... creation initialized&#34;</span> ++++++++++++

echo +++++++++++++ <span style="color:#e6db74">&#34;Have you cut the frames of </span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74"> to 4:3 aspect ratio?&#34;</span> ++++++++++++ read -p <span style="color:#e6db74">&#34;Of course I did!&#34;</span>

echo +++++++++ <span style="color:#e6db74">&#34;Define parameters&#34;</span> ++++++++++ echo <span style="color:#e6db74">&#34;Please enter its RANK (4 digits):&#34;</span> read INPUT_RANK echo <span style="color:#e6db74">&#34;Please enter the framerate:&#34;</span> read INPUT_FRAMERATE echo <span style="color:#e6db74">&#34;Please enter the length in number of frames:&#34;</span> read INPUT_LENGTH

echo +++++++++ <span style="color:#e6db74">&#34;Create directory for scene&#34;</span> ++++++++++ mkdir -p 02_scenes/$INPUT_SCENE


<span style="color:#75715e"># if directory is already existing, no error is given due to the -p</span>

echo +++++++++ <span style="color:#e6db74">&#34;Copy frames to newly created directory&#34;</span> ++++++++++

<span style="color:#75715e"># should be 4:3</span>
mv ~/*.jpg 02_scenes/$INPUT_SCENE

echo +++++++++ <span style="color:#e6db74">&#34;Resize frames&#34;</span> ++++++++++ mogrify -resize $HEIGHT 02_scenes/$INPUT_SCENE/frame_*.jpg


<span style="color:#75715e"># only frames, to prevent original photos;</span>

<span style="color:#75715e"># imagemagick is used for this</span>

echo +++++++++++++ <span style="color:#e6db74">&#34;Rename by adding the scene&#39;s name and rank&#34;</span> ++++++++++++

<span style="color:#75715e"># if the name is not congruent with the entries of the cutlist; rank is necessary for the order of the cat command later on</span>

<span style="color:#75715e"># only frames, to prevent original photos</span>

<span style="color:#66d9ef">for</span> FILE in 02_scenes/$INPUT_SCENE/frame_*.jpg ; <span style="color:#66d9ef">do</span> NEWFILE<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>echo $FILE | sed <span style="color:#e6db74">&#34;s/frame/</span>$INPUT_RANK<span style="color:#e6db74">\_</span>$INPUT_SCENE<span style="color:#e6db74">\_frame/g&#34;</span><span style="color:#e6db74">`</span> ; mv <span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> $NEWFILE ; <span style="color:#66d9ef">done</span>

echo +++++++++++++ <span style="color:#e6db74">&#34;Render </span>$SCENE<span style="color:#e6db74">&#34;</span> ++++++++++++ ffmpeg -loop_input -f image2 -r $INPUT_FRAMERATE -i <span style="color:#e6db74">&#34;02_scenes/</span>$INPUT_SCENE<span style="color:#e6db74">/</span><span style="color:#e6db74">${</span>INPUT_RANK<span style="color:#e6db74">}</span><span style="color:#e6db74">_</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">_frame_%04d.jpg&#34;</span> -b $BITRATE -r $FRAMERATE_END -vframes $INPUT_LENGTH <span style="color:#e6db74">&#34;03_output/</span><span style="color:#e6db74">${</span>INPUT_RANK<span style="color:#e6db74">}</span><span style="color:#e6db74">_</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">_output.avi&#34;</span>

<span style="color:#75715e"># {} are necessary to preserve the following underscore</span>

<span style="color:#75715e"># no overwrite (-y) needed</span>

<span style="color:#75715e"># the framerate of the output is necessary to keep the framerate differences of the scenes</span>

echo +++++++++++++ <span style="color:#e6db74">&#34;Write variables to cutlist.csv&#34;</span> ++++++++++++ echo <span style="color:#e6db74">&#34;</span>$INPUT_RANK<span style="color:#e6db74">;</span>$INPUT_SCENE<span style="color:#e6db74">;</span>$INPUT_FRAMERATE<span style="color:#e6db74">;</span>$INPUT_LENGTH<span style="color:#e6db74">;&#34;</span> &gt;&gt; cutlist.csv read -p <span style="color:#e6db74">&#34;Done!&#34;</span>

<span style="color:#75715e"># as a last step after everything was successful to prevent errors in the cutlist</span>

<span style="color:#75715e"># if scene already in the cutlist</span>

<span style="color:#66d9ef">else</span>

<span style="color:#75715e">## ############################################ BLOCK 03</span>

echo +++++++++++++ <span style="color:#e6db74">&#34;</span>$INPUT_SCENE<span style="color:#e6db74"> is already existing&#34;</span> ++++++++++++ echo +++++++++++++ <span style="color:#e6db74">&#34;Read defined parameters of </span>$INPUT_SCENE<span style="color:#e6db74">&#34;</span> ++++++++++++


<span style="color:#75715e"># Define Functions RANK, FRAMERATE, LENGTH by reading cutlist.csv</span>

RANK <span style="color:#f92672">()</span> <span style="color:#f92672">{</span> grep <span style="color:#e6db74">&#34;</span>$INPUT_SCENE<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">1</span> - <span style="color:#f92672">}</span> FRAMERATE <span style="color:#f92672">()</span> <span style="color:#f92672">{</span> grep <span style="color:#e6db74">&#34;</span>$INPUT_SCENE<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">3</span> - <span style="color:#f92672">}</span> LENGTH <span style="color:#f92672">()</span> <span style="color:#f92672">{</span> grep <span style="color:#e6db74">&#34;</span>$INPUT_SCENE<span style="color:#e6db74">&#34;</span> cutlist.csv | csvtool -t <span style="color:#e6db74">&#39;;&#39;</span> col <span style="color:#ae81ff">4</span> - <span style="color:#f92672">}</span> echo <span style="color:#e6db74">&#34;scene = </span>$INPUT_SCENE<span style="color:#e6db74">&#34;</span> echo <span style="color:#e6db74">&#34;rank = `RANK`&#34;</span> echo <span style="color:#e6db74">&#34;framerate = `FRAMERATE`&#34;</span> echo <span style="color:#e6db74">&#34;length = `LENGTH`&#34;</span> echo +++++++++++++ <span style="color:#e6db74">&#34; The rank of </span>$INPUT_SCENE<span style="color:#e6db74"> changed ... renaming &#34;</span> ++++++++++++



<span style="color:#75715e"># warning about too many arguments, because finding lots of files?? but it works</span>


blod <span style="color:#f92672">()</span> <span style="color:#f92672">{</span> find ./02_scenes/$INPUT_SCENE -name <span style="color:#e6db74">`</span>RANK<span style="color:#e6db74">`</span>_<span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span>* <span style="color:#f92672">}</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z <span style="color:#e6db74">`</span>blod<span style="color:#e6db74">`</span> <span style="color:#f92672">]</span>



<span style="color:#75715e"># if the rank is not matching the one of the cutlist, it needs to be changed</span>


<span style="color:#66d9ef">then</span> echo +++++++++++++ <span style="color:#e6db74">&#34;Rename </span>$INPUT_SCENE<span style="color:#e6db74"> by updating its name and rank&#34;</span> ++++++++++++ <span style="color:#66d9ef">for</span> FILE in 02_scenes/$INPUT_SCENE/_frame_.jpg ; <span style="color:#66d9ef">do</span> NEWFILE <span style="color:#f92672">()</span> <span style="color:#f92672">{</span> echo $FILE | sed <span style="color:#e6db74">&#34;s/</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">\/.*_.*_frame/</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">\/`RANK`\_</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">_frame/g&#34;</span> <span style="color:#f92672">}</span> mv <span style="color:#e6db74">&#34;</span>$FILE<span style="color:#e6db74">&#34;</span> <span style="color:#e6db74">`</span>NEWFILE<span style="color:#e6db74">`</span> ; <span style="color:#66d9ef">done</span> <span style="color:#66d9ef">fi</span> echo +++++++++++++ <span style="color:#e6db74">&#34;Render </span>$SCENE<span style="color:#e6db74">&#34;</span> ++++++++++++ ffmpeg -loop_input -f image2 -r <span style="color:#e6db74">`</span>FRAMERATE<span style="color:#e6db74">`</span> -i <span style="color:#e6db74">&#34;02_scenes/</span>$INPUT_SCENE<span style="color:#e6db74">/`RANK`_</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">_frame_%04d.jpg&#34;</span> -b $BITRATE -r $FRAMERATE_END -vframes <span style="color:#e6db74">`</span>LENGTH<span style="color:#e6db74">`</span> <span style="color:#e6db74">&#34;03_output/`RANK`_</span><span style="color:#e6db74">${</span>INPUT_SCENE<span style="color:#e6db74">}</span><span style="color:#e6db74">_output.avi&#34;</span>



<span style="color:#75715e"># {} are necessary to preserve the following underscore</span>

<span style="color:#75715e"># the framerate of the output is necessary to keep the framerate differences of the scenes</span>


<span style="color:#66d9ef">fi</span>



<span style="color:#66d9ef">fi</span>

<span style="color:#75715e">## ############################################ FINAL BLOCK</span>

echo +++++++++ <span style="color:#e6db74">&#34;Remove expired output videos&#34;</span> ++++++++++

<span style="color:#75715e"># remove expired output videos, otherwise cat adds them to the final file</span>

<span style="color:#66d9ef">for</span> I in 03_output/*_output.avi <span style="color:#66d9ef">do</span> temp<span style="color:#f92672">=</span><span style="color:#e6db74">`</span>echo <span style="color:#e6db74">&#34;</span>$I<span style="color:#e6db74">&#34;</span> | cut -c 11- | cut -d <span style="color:#e6db74">&#39;_&#39;</span> -f 1-2 | sed <span style="color:#e6db74">&#34;s/_/;/g&#34;</span><span style="color:#e6db74">`</span><span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> -z<span style="color:#e6db74">`</span>grep $temp cutlist.csv<span style="color:#e6db74">`</span> <span style="color:#f92672">]</span> <span style="color:#66d9ef">then</span> echo delete $I ??? rm -i $I <span style="color:#66d9ef">fi</span> <span style="color:#66d9ef">done</span>

<span style="color:#75715e"># the ls gives the path, cut removes the same path on the 11th digit and passes on the rest, cut separates the output at the &#39;_&#39; sign (recognizes fields) and provides the first two fields, sed is substitutes the &#39;_&#39; with a semicolon as used in the cutlist, and finally this string is looked up in the cutlist</span>

echo +++++++++ <span style="color:#e6db74">&#34;Merge all videos&#34;</span> ++++++++++ cat 03_output/*output.avi &gt; 03_output/output_video.avi

<span style="color:#75715e"># the rank must be correct for the sequence of the scenes</span>

echo +++++++++++ <span style="color:#e6db74">&#34;Add sound&#34;</span> +++++++++++ ffmpeg -y -shortest -i 03_output/output_video.avi -vcodec copy -b $BITRATE -r $FRAMERATE_END -i 03_output/output_sound.mp3 -acodec copy <span style="color:#e6db74">&#34;invent_a_fire.avi&#34;</span>

<span style="color:#75715e"># should be a formality, the shortest input ends the the file</span>

exit
</code></pre></div>]]></content></item></channel></rss>